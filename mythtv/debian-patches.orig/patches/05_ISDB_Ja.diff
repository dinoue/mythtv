Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythbase/logging.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythbase/logging.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythbase/logging.cpp
@@ -1104,7 +1104,7 @@ int verboseArgParse(const QString& arg)
 ///                 errno value itself.
 QString logStrerror(int errnum)
 {
-    return QString("%1 (%2)").arg(strerror(errnum)).arg(errnum);
+    return QString("%1 (%2)").arg(QString::fromLocal8Bit(strerror(errnum))).arg(errnum);
 }
 
 
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/cardutil.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/cardutil.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/cardutil.cpp
@@ -773,6 +773,15 @@ DTVTunerType CardUtil::ConvertToTunerTyp
         case DTVModulationSystem::kModulationSystem_DMBTH:
             tunertype = DTVTunerType::kTunerTypeDVBT;
             break;
+        case DTVModulationSystem::kModulationSystem_ISDBT:
+            tunertype = DTVTunerType::kTunerTypeDVBT;
+            break;
+        case DTVModulationSystem::kModulationSystem_ISDBS:
+            tunertype = DTVTunerType::kTunerTypeDVBS1; // ISDB-S still be WRAPPING of DVBS1
+            break;
+        case DTVModulationSystem::kModulationSystem_ISDBC:
+            tunertype = DTVTunerType::kTunerTypeDVBC;
+            break;
         case DTVModulationSystem::kModulationSystem_ATSC:
             tunertype = DTVTunerType::kTunerTypeATSC;
             break;
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/dtvmultiplex.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/dtvmultiplex.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/dtvmultiplex.cpp
@@ -425,7 +425,7 @@ bool DTVMultiplex::FillFromDB(DTVTunerTy
         "       hp_code_rate,      lp_code_rate,   constellation, "
         "       transmission_mode, guard_interval, hierarchy, "
         "       modulation,        bandwidth,      sistandard, "
-        "       mod_sys,           rolloff "
+        "       mod_sys,           rolloff,        transportid "
         "FROM dtv_multiplex "
         "WHERE dtv_multiplex.mplexid = :MPLEXID");
     query.bindValue(":MPLEXID", mplexid);
@@ -447,6 +447,7 @@ bool DTVMultiplex::FillFromDB(DTVTunerTy
 
     m_mplex = mplexid;
     m_sistandard = query.value(13).toString();
+    m_transportid = query.value(16).toInt();
 
     // Parse the query into our DVBTuning class
     return ParseTuningParams(
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/dtvmultiplex.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/dtvmultiplex.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/dtvmultiplex.h
@@ -110,6 +110,7 @@ class MTV_PUBLIC DTVMultiplex
     uint             m_mplex      {0};
     QString          m_sistandard;
     IPTVTuningData   m_iptvTuning;
+    uint             m_transportid;
 };
 
 class MTV_PUBLIC ScanDTVTransport : public DTVMultiplex
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/eithelper.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/eithelper.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/eithelper.cpp
@@ -206,11 +206,12 @@ void EITHelper::AddETT(uint atsc_major,
 static void parse_dvb_event_descriptors(const desc_list_t& list, FixupValue fix,
                                         QMap<uint,uint> languagePreferences,
                                         QString &title, QString &subtitle,
-                                        QString &description, QMap<QString,QString> &items)
+                                        QString &description, QMap<QString,QString> &items,
+				        DVBKind dvbkind)
 {
     const unsigned char *bestShortEvent =
-        MPEGDescriptor::FindBestMatch(
-            list, DescriptorID::short_event, languagePreferences);
+        DVBDescriptor::FindBestMatch(
+            list, DescriptorID::short_event, languagePreferences, dvbkind);
 
     // from EN 300 468, Appendix A.2 - Selection of character table
     unsigned char enc_1[3]  = { 0x10, 0x00, 0x01 };
@@ -263,26 +264,41 @@ static void parse_dvb_event_descriptors(
 
     if (bestShortEvent)
     {
-        ShortEventDescriptor sed(bestShortEvent);
+        QRegExp pre_pattern(QString::fromUtf8("^((\\[.{1,2}\\]|【.】|<[^>]+>|5[\\.．]1)+)")); 
+        QRegExp suf_pattern(QString::fromUtf8(".+(?:〜[^〜]+〜)?.*(?:(?:-[^\\-]+-)|(?:−[^−]+−))?.*(((\\[.{1,2}\\])+|[#＃]\\d+|\\([#＃]?\\d+\\)|（[#＃]?\\d+）|vol\\.\\d+|\\(?第(?!.{1,3}部)|最終回|「(?![^」]+」(.?[<＜]|.*[#＃第]\\d+))|[<＜【▽◆]).*)"), Qt::CaseInsensitive); 
+        ShortEventDescriptor sed(bestShortEvent, dvbkind);
         if (sed.IsValid())
         {
             if (enc)
             {
                 title    = sed.EventName(enc, enc_len);
-                subtitle = sed.Text(enc, enc_len);
+				pre_pattern.indexIn(title);
+				subtitle = pre_pattern.cap(1);
+				title    = title.remove(pre_pattern);
+				suf_pattern.indexIn(title);
+				subtitle += suf_pattern.cap(1);
+				title    = title.remove(suf_pattern.cap(1)).trimmed();
+				subtitle += sed.Text(enc, enc_len);
             }
             else
             {
                 title    = sed.EventName();
-                subtitle = sed.Text();
+				pre_pattern.indexIn(title);
+				subtitle = pre_pattern.cap(1);
+				title    = title.remove(pre_pattern);
+				suf_pattern.indexIn(title);
+				subtitle += suf_pattern.cap(1);
+				title    = title.remove(suf_pattern.cap(1)).trimmed();
+				subtitle += sed.Text();
             }
         }
     }
 
     vector<const unsigned char*> bestExtendedEvents =
-        MPEGDescriptor::FindBestMatches(
-            list, DescriptorID::extended_event, languagePreferences);
+        DVBDescriptor::FindBestMatches(
+            list, DescriptorID::extended_event, languagePreferences, dvbkind);
 
+    QByteArray saved_text;
     description = "";
     for (auto & best_event : bestExtendedEvents)
     {
@@ -292,10 +308,12 @@ static void parse_dvb_event_descriptors(
             break;
         }
 
-        ExtendedEventDescriptor eed(best_event);
+        ExtendedEventDescriptor eed(best_event, dvbkind);
         if (eed.IsValid())
         {
-            if (enc)
+			if (dvbkind == kKindISDB)
+				description += eed.ItemText(saved_text);
+			else if (enc)
                 description += eed.Text(enc, enc_len);
             else
                 description += eed.Text();
@@ -303,6 +321,12 @@ static void parse_dvb_event_descriptors(
         // add items from the decscriptor to the items
         items.unite (eed.Items());
     }
+    if (dvbkind == kKindISDB && !saved_text.isEmpty()) {
+        DVBDescriptor d(NULL, kKindISDB, 0);
+        description += d.dvb_decode_text((unsigned char *)saved_text.data(),
+                                         saved_text.size());
+        description += "\n";
+    }
 }
 
 static inline void parse_dvb_component_descriptors(const desc_list_t& list,
@@ -358,6 +382,7 @@ void EITHelper::AddEIT(const DVBEventInf
 
     uint tableid   = eit->TableID();
     uint version   = eit->Version();
+    DVBKind dvbkind = eit->DVBKindStatus();
     for (uint i = 0; i < eit->EventCount(); i++)
     {
         // Skip event if we have already processed it before...
@@ -409,8 +434,8 @@ void EITHelper::AddEIT(const DVBEventInf
         }
         else
         {
-            parse_dvb_event_descriptors(list, fix, m_languagePreferences,
-                                        title, subtitle, description, items);
+				parse_dvb_event_descriptors(list, fix, m_languagePreferences,
+                                        title, subtitle, description, items, dvbkind);
         }
 
         parse_dvb_component_descriptors(list, subtitle_type, audio_props,
@@ -491,8 +516,8 @@ void EITHelper::AddEIT(const DVBEventInf
         {
             if ((EITFixUp::kFixDish & fix) || (EITFixUp::kFixBell & fix))
             {
-                DishContentDescriptor content(content_data);
-                switch (content.GetTheme())
+                DishContentDescriptor content(content_data, dvbkind);
+                switch (content.GetTheme(dvbkind))
                 {
                     case kThemeMovie :
                         category_type = ProgramInfo::kCategoryMovie;
@@ -507,7 +532,7 @@ void EITHelper::AddEIT(const DVBEventInf
                         category_type = ProgramInfo::kCategoryNone;
                 }
                 if (EITFixUp::kFixDish & fix)
-                    category  = content.GetCategory();
+                    category  = content.GetCategory(dvbkind);
             }
             else if (EITFixUp::kFixAUDescription & fix)//AU Freeview assigned genres
             {
@@ -517,7 +542,7 @@ void EITHelper::AddEIT(const DVBEventInf
                      /* 8*/"Current Affairs", "Education", "Infotainment",
                      /*11*/"Special", "Comedy", "Drama", "Documentary",
                      /*15*/"Unknown"};
-                ContentDescriptor content(content_data);
+                ContentDescriptor content(content_data, dvbkind);
                 if (content.IsValid())
                 {
                     category = s_auGenres[content.Nibble1(0)];
@@ -531,7 +556,7 @@ void EITHelper::AddEIT(const DVBEventInf
                      /* 4*/"Αθλητικό", "Παιδικό", "Unknown", "Unknown",
                      /* 8*/"Unknown", "Ντοκιμαντέρ", "Unknown", "Unknown",
                      /*12*/"Unknown", "Unknown", "Unknown", "Unknown"};
-                ContentDescriptor content(content_data);
+                ContentDescriptor content(content_data, dvbkind);
                 if (content.IsValid())
                 {
                     category = s_grGenres[content.Nibble2(0)];
@@ -540,7 +565,7 @@ void EITHelper::AddEIT(const DVBEventInf
             }
             else
             {
-                ContentDescriptor content(content_data);
+                ContentDescriptor content(content_data, dvbkind);
                 if (content.IsValid())
                 {
                     category      = content.GetDescription(0);
@@ -659,7 +684,7 @@ void EITHelper::AddEIT(const PremiereCon
         cit->Descriptors(), cit->DescriptorsLength());
 
     parse_dvb_event_descriptors(list, fix, m_languagePreferences,
-                                title, subtitle, description, items);
+                                title, subtitle, description, items, kKindDVB);
 
     parse_dvb_component_descriptors(list, subtitle_type, audio_props,
                                     video_props);
@@ -668,7 +693,7 @@ void EITHelper::AddEIT(const PremiereCon
         MPEGDescriptor::Find(list, DescriptorID::content);
     if (content_data)
     {
-        ContentDescriptor content(content_data);
+        ContentDescriptor content(content_data, kKindDVB);
         // fix events without real content data
         if (content.IsValid() && (content.Nibble(0)==0x00))
         {
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/eithelper.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/eithelper.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/eithelper.h
@@ -9,6 +9,7 @@
 #include <utility>
 
 // Qt includes
+#include <QByteArray>
 #include <QDateTime>
 #include <QMap>
 #include <QMutex>
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/frequencytables.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/frequencytables.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/frequencytables.cpp
@@ -507,6 +507,16 @@ static void init_freq_tables(freq_table_
         DTVGuardInterval::kGuardIntervalAuto, DTVHierarchy::kHierarchyNone,
         DTVModulation::kModulationQAMAuto, 143000, 0);
 
+    // Japan (ISDB-T)
+    fmap["dvbt_ofdm_jp0"] = new FrequencyTable(
+       473142857, 803142857, 6000000, "Channel %1", 13,
+        DTVInversion::kInversionAuto,
+        DTVBandwidth::kBandwidth6MHz, DTVCodeRate::kFECAuto,
+        DTVCodeRate::kFECAuto, DTVModulation::kModulationQAMAuto,
+        DTVTransmitMode::kTransmissionMode2K,
+        DTVGuardInterval::kGuardInterval_1_16, DTVHierarchy::kHierarchyNone,
+        DTVModulation::kModulationQAMAuto, 0, -0);
+
     // DVB-C Germany
     fmap["dvbc_qam_de0"] = new FrequencyTable(
          73000000,  73000000, 8000000, "Channel D%1", 73,
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/libmythtv.pro
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/libmythtv.pro
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/libmythtv.pro
@@ -207,6 +207,7 @@ HEADERS += mpeg/tsstats.h           mpeg
 HEADERS += mpeg/H264Parser.h
 HEADERS += mpeg/tablestatus.h
 HEADERS += mpeg/tsstreamdata.h
+HEADERS += mpeg/isdb_decode_text.h
 
 SOURCES += mpeg/tspacket.cpp        mpeg/pespacket.cpp
 SOURCES += mpeg/mpegtables.cpp      mpeg/atsctables.cpp
@@ -224,6 +225,7 @@ SOURCES += mpeg/iso6937tables.cpp
 SOURCES += mpeg/H264Parser.cpp
 SOURCES += mpeg/tablestatus.cpp
 SOURCES += mpeg/tsstreamdata.cpp
+SOURCES += mpeg/isdb_decode_text.c
 
 # Channels, and the multiplexes that transmit them
 HEADERS += frequencies.h            frequencytables.h
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/H264Parser.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/H264Parser.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/H264Parser.h
@@ -29,8 +29,9 @@
 // unistd.h up front so that the subsequent inclusions will be
 // skipped, and then define NULL to the right value.
 #include <unistd.h>
-#undef NULL
-#define NULL nullptr
+
+//#undef NULL
+//#define NULL nullptr
 
 #include <QString>
 #include <cstdint>
@@ -44,8 +45,8 @@
 // copied from libavutil/internal.h
 extern "C" {
 // Grr. NULL keeps getting redefined back to 0
-#undef NULL
-#define NULL nullptr
+//#undef NULL
+//#define NULL nullptr
 #include "libavutil/common.h" // for AV_GCC_VERSION_AT_LEAST()
 }
 #ifndef av_alias
@@ -58,8 +59,8 @@ extern "C" {
 
 extern "C" {
 // Grr. NULL keeps getting redefined back to 0
-#undef NULL
-#define NULL nullptr
+//#undef NULL
+//#define NULL nullptr
 #include "libavcodec/get_bits.h"
 }
 
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dishdescriptors.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dishdescriptors.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dishdescriptors.cpp
@@ -8,6 +8,7 @@
 #include "atsc_huffman.h"
 #include "programinfo.h" // for subtitle types and audio and video properties
 #include "dvbtables.h"
+#include "dvbdescriptors.h"
 
 QString DishEventNameDescriptor::Name(uint compression_type) const
 {
@@ -151,7 +152,7 @@ QDate DishEventTagsDescriptor::originala
     mjd[3] = 0;
     mjd[4] = 0;
 
-    QDateTime t = dvbdate2qt(mjd);
+    QDateTime t = dvbdate2qt(mjd, kKindDVB);
 
     if (!t.isValid())
         return {};
@@ -328,10 +329,10 @@ DishThemeType string_to_dish_theme_type(
     return kThemeNone;
 }
 
-DishThemeType DishContentDescriptor::GetTheme(void) const
+DishThemeType DishContentDescriptor::GetTheme(DVBKind dvbkind) const
 {
     if (!s_dishCategoryDescExists)
-        Init();
+        Init(dvbkind);
 
     if (Nibble1(0) == 0x00)
         return kThemeOffAir;
@@ -344,10 +345,10 @@ DishThemeType DishContentDescriptor::Get
     return kThemeNone;
 }
 
-QString DishContentDescriptor::GetCategory(void) const
+QString DishContentDescriptor::GetCategory(DVBKind dvbkind) const
 {
     if (!s_dishCategoryDescExists)
-        Init();
+        Init(_dvbkind);
 
     QMutexLocker locker(&s_categoryLock);
 
@@ -358,19 +359,19 @@ QString DishContentDescriptor::GetCatego
         return *it;
 
     // Fallback to just the theme
-    QString theme = dish_theme_type_to_string(GetTheme());
+    QString theme = dish_theme_type_to_string(GetTheme(_dvbkind));
 
     return theme;
 }
 
 QString DishContentDescriptor::toString() const
 {
-    return QString("%1 : %2").arg(int(GetTheme())).arg(GetCategory());
+    return QString("%1 : %2").arg(int(GetTheme(_dvbkind))).arg(GetCategory(_dvbkind));
 }
 
-void DishContentDescriptor::Init(void)
+void DishContentDescriptor::Init(DVBKind dvbkind)
 {
-    ContentDescriptor::Init();
+    ContentDescriptor::Init(dvbkind);
 
     QMutexLocker locker(&s_categoryLock);
 
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dishdescriptors.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dishdescriptors.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dishdescriptors.h
@@ -155,15 +155,15 @@ DishThemeType string_to_dish_theme_type(
 class DishContentDescriptor : public ContentDescriptor
 {
   public:
-    explicit DishContentDescriptor(const unsigned char *data, int len = 300) :
-        ContentDescriptor(data, len) { }
+    explicit DishContentDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        ContentDescriptor(data, dvbkind, len) { }
 
-    DishThemeType GetTheme(void) const;
-    QString GetCategory(void) const;
+    DishThemeType GetTheme(DVBKind dvbkind) const;
+    QString GetCategory(DVBKind dvbkind) const;
     QString toString() const override; // ContentDescriptor
 
   private:
-    static void Init(void);
+    static void Init(DVBKind dvbkind);
 
   private:
     static QMap<uint,QString> s_themeDesc;
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbdescriptors.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dvbdescriptors.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbdescriptors.cpp
@@ -1,5 +1,6 @@
 // C headers
 #include <unistd.h>
+#include <limits.h>
 #include <algorithm>
 
 // Qt headers
@@ -51,16 +52,34 @@ static QString decode_iso6937(const unsi
 
 static QString decode_text(const unsigned char *buf, uint length);
 
-// Decode a text string according to ETSI EN 300 468 Annex A
-QString dvb_decode_text(const unsigned char *src, uint raw_length,
+// Decode a text string according to ETSI EN 300 468 Annex A or ISDB/ARIB STD-24
+QString DVBDescriptor::dvb_decode_text(const unsigned char *src, uint raw_length,
                         const unsigned char *encoding_override,
-                        uint encoding_override_length)
+                        uint encoding_override_length) const
 {
     if (!raw_length)
         return "";
 
+    if (_dvbkind == kKindISDB)
+    {
+        unsigned char buf[4096 * 6];
+        unsigned int len;
+        len = isdb_decode_text(hisdbdecode, src, (unsigned int)raw_length,
+                               buf, (unsigned int)sizeof(buf));
+        return QString::fromUtf8((const char *)buf, (int)len).
+           replace(QString("\n"), QString(" ")); 
+    }
+
     if (src[0] == 0x1f)
         return freesat_huffman_to_string(src, raw_length);
+   
+    if (src[0] == 0x15) 
+	return QString::fromUtf8((char *)(src + 1), raw_length - 1). 
+	    replace(QString("\n"), QString(" ")); 
+    else if (src[0] == 0x11) 
+	return QTextCodec::codecForName("UTF-16BE")->toUnicode((char *)(src + 1), raw_length - 1). 
+	    replace(QString("\n"), QString(" ")); 
+
 
     /* UCS-2 aka ISO/IEC 10646-1 Basic Multilingual Plane */
     if (src[0] == 0x11)
@@ -172,7 +191,7 @@ static QString decode_text(const unsigne
 }
 
 
-QString dvb_decode_short_name(const unsigned char *src, uint raw_length)
+QString DVBDescriptor::dvb_decode_short_name(const unsigned char *src, uint raw_length) const
 {
     if (raw_length > 50)
     {
@@ -183,6 +202,27 @@ QString dvb_decode_short_name(const unsi
         return "";
     }
 
+    if (src[0] == 0x15) 
+	return QString::fromUtf8((char *)(src + 1), raw_length - 1). 
+	    replace(QString("\n"), QString(" ")); 
+    else if (src[0] == 0x11) 
+	return QTextCodec::codecForName("UTF-16BE")->toUnicode((char *)(src + 1), raw_length - 1). 
+	    replace(QString("\n"), QString(" ")); 
+
+    if (_dvbkind == kKindISDB)
+    {
+        unsigned char buf[50 * 6];
+        unsigned int len;
+        len = isdb_decode_text(hisdbdecode, src, (unsigned int)raw_length,
+                               buf, (unsigned int)sizeof(buf));
+        return QString::fromUtf8((const char *)buf, (int)len).
+           replace(QString("\n"), QString(" ")); 
+    }
+
+    if (src[0] == 0x11) 
+       return QTextCodec::codecForName("UTF-16BE")->toUnicode((char *)(src + 1), raw_length - 1). 
+           replace(QString("\n"), QString(" ")); 
+
     if (((0x10 < src[0]) && (src[0] < 0x15)) ||
         ((0x15 < src[0]) && (src[0] < 0x20)))
     {
@@ -223,12 +263,149 @@ QString dvb_decode_short_name(const unsi
     return sStr;
 }
 
+
+static uint maxPriority(const QMap<uint,uint> &langPrefs)
+{
+    uint max_pri = 0;
+    QMap<uint,uint>::const_iterator it = langPrefs.begin();
+    for (; it != langPrefs.end(); ++it)
+        max_pri = max(max_pri, *it);
+    return max_pri;
+}
+
+const unsigned char *DVBDescriptor::FindBestMatch(
+    const desc_list_t &parsed, uint desc_tag, QMap<uint,uint> &langPrefs, DVBKind dvbkind)
+{
+    uint match_idx = 0;
+    uint match_pri = UINT_MAX;
+    int  unmatched_idx = -1;
+
+    uint i = (desc_tag == DescriptorID::short_event) ? 0 : parsed.size();
+    for (; i < parsed.size(); i++)
+    {
+        if (DescriptorID::short_event == parsed[i][0])
+        {
+            ShortEventDescriptor sed(parsed[i], dvbkind);
+            QMap<uint,uint>::const_iterator it =
+                langPrefs.find(sed.CanonicalLanguageKey());
+
+            if ((it != langPrefs.end()) && (*it < match_pri))
+            {
+                match_idx = i;
+                match_pri = *it;
+            }
+
+            if (unmatched_idx < 0)
+                unmatched_idx = i;
+        }
+    }
+
+    if (match_pri != UINT_MAX)
+        return parsed[match_idx];
+
+    if ((desc_tag == DescriptorID::short_event) && (unmatched_idx >= 0))
+    {
+        ShortEventDescriptor sed(parsed[unmatched_idx], dvbkind);
+        langPrefs[sed.CanonicalLanguageKey()] = maxPriority(langPrefs) + 1;
+        return parsed[unmatched_idx];
+    }
+
+    return NULL;
+}
+
+desc_list_t DVBDescriptor::FindBestMatches(
+    const desc_list_t &parsed, uint desc_tag, QMap<uint,uint> &langPrefs, DVBKind dvbkind)
+{
+    uint match_pri = UINT_MAX;
+    int  match_key = 0;
+    int  unmatched_idx = -1;
+
+    uint i = (desc_tag == DescriptorID::extended_event) ? 0 : parsed.size();
+    for (; i < parsed.size(); i++)
+    {
+        if (DescriptorID::extended_event == parsed[i][0])
+        {
+            ExtendedEventDescriptor eed(parsed[i], dvbkind);
+            QMap<uint,uint>::const_iterator it =
+                langPrefs.find(eed.CanonicalLanguageKey());
+
+            if ((it != langPrefs.end()) && (*it < match_pri))
+            {
+                match_key = eed.LanguageKey();
+                match_pri = *it;
+            }
+            if (unmatched_idx < 0)
+                unmatched_idx = i;
+        }
+    }
+
+    if ((desc_tag == DescriptorID::extended_event) &&
+        (match_key == 0) && (unmatched_idx >= 0))
+    {
+        ExtendedEventDescriptor eed(parsed[unmatched_idx], dvbkind);
+        langPrefs[eed.CanonicalLanguageKey()] = maxPriority(langPrefs) + 1;
+        match_key = eed.LanguageKey();
+    }
+
+    desc_list_t tmp;
+    if (match_pri == UINT_MAX)
+        return tmp;
+
+    for (uint i = 0; i < parsed.size(); i++)
+    {
+        if ((DescriptorID::extended_event == desc_tag) &&
+            (DescriptorID::extended_event == parsed[i][0]))
+        {
+            ExtendedEventDescriptor eed(parsed[i], dvbkind);
+            if (eed.LanguageKey() == match_key)
+                tmp.push_back(parsed[i]);
+        }
+    }
+    return tmp;
+}
+
+#define SET_STRING(DESC_NAME) do { \
+    if (IsValid()) { DESC_NAME d(m_data, _dvbkind, DescriptorLength()+2); \
+    if (d.IsValid()) str = d.toString(); } } while (0)
+
+QString DVBDescriptor::toString() const
+{
+    QString str;
+
+    if (DescriptorID::network_name == DescriptorTag())
+        SET_STRING(NetworkNameDescriptor);
+    else if (DescriptorID::service == DescriptorTag())
+        SET_STRING(ServiceDescriptor);
+    else if (DescriptorID::bouquet_name == DescriptorTag())
+        SET_STRING(BouquetNameDescriptor);
+    else if (IsValid())
+    {
+        str = QString("%1 Descriptor (0x%2) length(%3)")
+            .arg(DescriptorTagString())
+            .arg(DescriptorTag(),2,16,QChar('0'))
+            .arg(DescriptorLength());
+     }
+     else
+     {
+         str = "Invalid Descriptor";
+     }
+     return str;
+}
+
 QMutex             ContentDescriptor::s_categoryLock;
 QMap<uint,QString> ContentDescriptor::s_categoryDesc;
 volatile bool      ContentDescriptor::s_categoryDescExists = false;
 
 ProgramInfo::CategoryType ContentDescriptor::GetMythCategory(uint i) const
 {
+    if (_dvbkind == kKindISDB) {
+        if (0x6 == Nibble1(i))
+            return ProgramInfo::kCategoryMovie;
+        if (0x1 == Nibble1(i))
+            return ProgramInfo::kCategorySports;
+        return ProgramInfo::kCategoryTVShow;
+    }
+
     if (0x1 == Nibble1(i))
         return ProgramInfo::kCategoryMovie;
     if (0x4 == Nibble1(i))
@@ -278,7 +455,7 @@ QString LinkageDescriptor::MobileHandOve
 QString ContentDescriptor::GetDescription(uint i) const
 {
     if (!s_categoryDescExists)
-        Init();
+        Init(_dvbkind);
 
     QMutexLocker locker(&s_categoryLock);
 
@@ -304,7 +481,7 @@ QString ContentDescriptor::toString() co
     return tmp;
 }
 
-void ContentDescriptor::Init(void)
+void ContentDescriptor::Init(DVBKind dvbkind)
 {
     QMutexLocker locker(&s_categoryLock);
 
@@ -314,6 +491,47 @@ void ContentDescriptor::Init(void)
     //: %1 is the main category, %2 is the subcategory
     QString subCatStr = QCoreApplication::translate("(Categories)",
         "%1 - %2", "Category with subcategory display");
+	
+    if (dvbkind == kKindISDB) {
+        s_categoryDesc[0x00] = QCoreApplication::translate("(Categories)",
+                                                    "ニュース／報道", 0
+                                         );
+        s_categoryDesc[0x10] = QCoreApplication::translate("(Categories)",
+                                                          "スポーツ", 0
+                                         );
+        s_categoryDesc[0x20] = QCoreApplication::translate("(Categories)",
+                                                "情報／ワイドショー", 0
+                                         );
+        s_categoryDesc[0x30] = QCoreApplication::translate("(Categories)",
+                                                            "ドラマ", 0
+                                         );
+        s_categoryDesc[0x40] = QCoreApplication::translate("(Categories)",
+                                                              "音楽", 0
+                                         );
+        s_categoryDesc[0x50] = QCoreApplication::translate("(Categories)",
+                                                        "バラエティ", 0
+                                         );
+        s_categoryDesc[0x60] = QCoreApplication::translate("(Categories)",
+                                                              "映画", 0
+                                         );
+        s_categoryDesc[0x70] = QCoreApplication::translate("(Categories)",
+                                                      "アニメ／特撮", 0
+                                         );
+        s_categoryDesc[0x80] = QCoreApplication::translate("(Categories)",
+                                            "ドキュメンタリー／教養", 0
+                                         );
+        s_categoryDesc[0x90] = QCoreApplication::translate("(Categories)",
+                                                        "劇場／公演", 0
+                                         );
+        s_categoryDesc[0xA0] = QCoreApplication::translate("(Categories)",
+                                                        "趣味／教育", 0
+                                         );
+        s_categoryDesc[0xB0] = QCoreApplication::translate("(Categories)",
+                                                              "福祉", 0
+                                         );
+        s_categoryDescExists = true;
+        return;
+    }
 
     s_categoryDesc[0x10] = QCoreApplication::translate("(Categories)", "Movie");
     s_categoryDesc[0x11] = subCatStr
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbdescriptors.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dvbdescriptors.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbdescriptors.h
@@ -5,12 +5,14 @@
 
 #include <cassert>
 
+#include <QByteArray>
 #include <QMutex>
 #include <QString>
 
 #include "mythtvexp.h" // MTV_PUBLIC - Symbol Visibility
 #include "mpegdescriptors.h"
 #include "programinfo.h" // for subtitle types and audio and video properties
+#include "isdb_decode_text.h"
 
 /*
 // needed for scanning
@@ -37,16 +39,50 @@
 
 static QString coderate_inner(uint coderate);
 
-extern QString dvb_decode_text(const unsigned char *src, uint length,
-                               const unsigned char *encoding_override,
-                               uint encoding_override_length);
-
-inline QString dvb_decode_text(const unsigned char *src, uint length)
+class DVBDescriptor : public MPEGDescriptor
 {
-    return dvb_decode_text(src, length, nullptr, 0);
-}
-
-QString dvb_decode_short_name(const unsigned char *src, uint raw_length);
+  public:
+    DVBDescriptor(const unsigned char *data, DVBKind dvbkind = kKindUnknown, int len = 300, uint tag = (uint)NULL)
+        : MPEGDescriptor(data, len, tag), _dvbkind(dvbkind)
+    {
+        if ((len < 2) || (int(DescriptorLength()) + 2) > len)
+            m_data = NULL;
+        else if (DescriptorTag() != tag)
+            m_data = NULL;
+        if (_dvbkind == kKindISDB) {
+            QDateTime dt1 = QDateTime::currentDateTime();
+            QDateTime dt2 = dt1.toUTC();
+            dt1.setTimeSpec(Qt::UTC);
+
+            int offset = dt2.secsTo(dt1) / 3600;
+            if (9 == offset)
+                hisdbdecode = isdb_decode_open(ISDB_ARIB);
+            else
+                hisdbdecode = isdb_decode_open(ISDB_ABNT);
+         }
+         else
+            hisdbdecode = (IsdbDecode)NULL;
+    }
+    virtual ~DVBDescriptor() {
+        if (hisdbdecode != (IsdbDecode)NULL)
+            isdb_decode_close(hisdbdecode);
+    }
+
+    static const unsigned char* FindBestMatch(
+        const desc_list_t &parsed, uint desc_tag, QMap<uint,uint> &langPref, DVBKind dvbkind);
+    static desc_list_t FindBestMatches(
+        const desc_list_t &parsed, uint desc_tag, QMap<uint,uint> &langPref, DVBKind dvbkind);
+
+    QString dvb_decode_text(const unsigned char *src, uint length,
+                            const unsigned char *encoding_override = NULL,
+                            uint encoding_override_length = 0) const;
+    QString dvb_decode_short_name(const unsigned char *src, uint raw_length) const;
+    virtual QString toString(void) const;
+  protected:
+    const DVBKind _dvbkind;
+  private:
+    IsdbDecode hisdbdecode;
+};
 
 #define byteBCDH2int(i) ((i) >> 4)
 #define byteBCDL2int(i) ((i) & 0x0f)
@@ -65,11 +101,11 @@ QString dvb_decode_short_name(const unsi
    byteBCDH2int(l) * 10         + byteBCDL2int(l))
 
 // DVB Bluebook A038 (Sept 2011) p 77
-class NetworkNameDescriptor : public MPEGDescriptor
+class NetworkNameDescriptor : public DVBDescriptor
 {
   public:
-    explicit NetworkNameDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::network_name) { }
+    explicit NetworkNameDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::network_name) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x40
     // descriptor_length        8   1.0
@@ -266,11 +302,11 @@ class AnnouncementSupportDescriptor : pu
 };
 
 // DVB Bluebook A038 (Sept 2011) p 41
-class BouquetNameDescriptor : public MPEGDescriptor
+class BouquetNameDescriptor : public DVBDescriptor
 {
   public:
-    explicit BouquetNameDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::bouquet_name) { }
+    explicit BouquetNameDescriptor(const unsigned char *data, DVBKind dvbkind,  int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::bouquet_name) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x47
     // descriptor_length        8   1.0
@@ -579,11 +615,11 @@ class ComponentDescriptor : public MPEGD
 };
 
 // DVB Bluebook A038 (Sept 2011) p 46
-class ContentDescriptor : public MPEGDescriptor
+class ContentDescriptor : public DVBDescriptor
 {
   public:
-    explicit ContentDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::content) { }
+    explicit ContentDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::content) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x54
     // descriptor_length        8   1.0
@@ -610,7 +646,7 @@ class ContentDescriptor : public MPEGDes
     QString toString(void) const override; // MPEGDescriptor
 
   protected:
-    static void Init(void);
+    static void Init(DVBKind dvbkind);
 
   protected:
     static QMutex             s_categoryLock;
@@ -656,11 +692,11 @@ class CountryAvailabilityDescriptor : pu
 };
 
 // DVB Bluebook A038 (Sept 2011) p 50
-class DataBroadcastDescriptor : public MPEGDescriptor
+class DataBroadcastDescriptor : public DVBDescriptor
 {
   public:
-    explicit DataBroadcastDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::data_broadcast) { }
+    explicit DataBroadcastDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::data_broadcast) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x64
     // descriptor_length        8   1.0
@@ -1085,11 +1121,11 @@ class DSNGDescriptor : public MPEGDescri
 };
 
 // DVB Bluebook A038 (Sept 2011) p 58
-class ExtendedEventDescriptor : public MPEGDescriptor
+class ExtendedEventDescriptor : public DVBDescriptor
 {
   public:
-    explicit ExtendedEventDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::extended_event) { }
+    explicit ExtendedEventDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::extended_event) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x4e
     // descriptor_length        8   1.0
@@ -1116,6 +1152,44 @@ class ExtendedEventDescriptor : public M
     //   item_length            8   1.0+p2
     //   for (j=0;j<N;j++) { item_char 8 }
     // }
+    QString ItemText(QByteArray& saved_text) const
+        {
+           QString     item;
+           uint        left, p = 7, ItemDescriptionLen, ItemLength;
+           item = "";
+           left = LengthOfItems();
+           while (left > 0) {
+               ItemDescriptionLen = m_data[p++];
+               p += ItemDescriptionLen;
+               ItemLength = m_data[p++];
+               if (ItemDescriptionLen > 0)
+                       saved_text.clear();
+               QByteArray item_byte =
+                   QByteArray::fromRawData((char *)&m_data[p], ItemLength);
+               left -= 2 + ItemDescriptionLen + ItemLength;
+               p += ItemLength;
+               if ((ItemLength == 200 || ItemLength == 220) && left == 0) {
+                       // might be split into the next extended event desc.
+                       saved_text = item_byte;
+                       return item;
+               }
+               // UNLIKELY
+               // join intra-desciptor split items
+               if (left >= 2 && ItemDescriptionLen > 0 && m_data[p] == 0) {
+                       saved_text = item_byte;
+                       continue;
+               }
+               if (ItemDescriptionLen == 0)
+                       item_byte.prepend(saved_text);
+               saved_text.clear();
+               item += dvb_decode_text((unsigned char *)item_byte.data(), item_byte.size());
+               if (ItemLength > 0)
+                   item += "\n";
+               if (left > 0)
+                   item += "\n";
+           }
+           return item;
+       }
     QMap<QString,QString> Items(void) const;
     // text_length 8
     uint TextLength(void)       const { return m_data[7 + LengthOfItems()]; }
@@ -1574,11 +1648,11 @@ class ServiceDescriptorMapping
 };
 
 // DVB Bluebook A038 (Sept 2011) p 80
-class ServiceDescriptor : public MPEGDescriptor
+class ServiceDescriptor : public DVBDescriptor
 {
   public:
-    explicit ServiceDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::service) { }
+    explicit ServiceDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::service) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x48
     // descriptor_length        8   1.0
@@ -1693,11 +1767,11 @@ class ServiceMoveDescriptor : public MPE
 };
 
 // DVB Bluebook A038 (Sept 2011) p 83
-class ShortEventDescriptor : public MPEGDescriptor
+class ShortEventDescriptor : public DVBDescriptor
 {
   public:
-    explicit ShortEventDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::short_event) { }
+    explicit ShortEventDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::short_event) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x4d
     // descriptor_length        8   1.0
@@ -1930,11 +2004,11 @@ class TimeShiftedServiceDescriptor : pub
 };
 
 // DVB Bluebook A038 (Sept 2011) p 90
-class TransportStreamDescriptor : public MPEGDescriptor
+class TransportStreamDescriptor : public DVBDescriptor
 {
   public:
-    explicit TransportStreamDescriptor(const unsigned char *data, int len = 300) :
-        MPEGDescriptor(data, len, DescriptorID::transport_stream) { }
+    explicit TransportStreamDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::transport_stream) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0x67
     // descriptor_length        8   1.0
@@ -2295,7 +2369,10 @@ class FreesatCallsignDescriptor : public
         { return QString::fromLatin1((char *) m_data +2, 3); }
 
     QString Callsign(void) const
-        { return dvb_decode_short_name(&m_data[6], m_data[5]); }
+	// Hack 20200324 K.O
+	{ return QString::fromLatin1((char *)(&m_data[6]), m_data[5]); }
+		
+	//        { return dvb_decode_short_name(&_data[6], _data[5]); }
 
     QString toString(void) const override; // MPEGDescriptor
 };
@@ -2473,11 +2550,11 @@ class DefaultAuthorityDescriptor : publi
 /*
  * private UPC Cablecom (Austria) episode descriptor for Horizon middleware
  */
-class PrivateUPCCablecomEpisodeTitleDescriptor : public MPEGDescriptor
+class PrivateUPCCablecomEpisodeTitleDescriptor : public DVBDescriptor
 {
     public:
-     explicit PrivateUPCCablecomEpisodeTitleDescriptor(const unsigned char *data, int len = 300) :
-         MPEGDescriptor(data, len, PrivateDescriptorID::upc_event_episode_title) { }
+     explicit PrivateUPCCablecomEpisodeTitleDescriptor(const unsigned char *data, int len = 300, DVBKind dvbkind = kKindISDB) :
+         DVBDescriptor(data, dvbkind, len, PrivateDescriptorID::upc_event_episode_title) { }
     //       Name             bits  loc  expected value
     // descriptor_tag           8   0.0       0xa7
     // descriptor_length        8   1.0
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbstreamdata.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dvbstreamdata.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbstreamdata.cpp
@@ -19,9 +19,11 @@ using namespace std;
 
 // service_id is synonymous with the MPEG program number in the PMT.
 DVBStreamData::DVBStreamData(uint desired_netid,  uint desired_tsid,
-                             int desired_program, int cardnum, bool cacheTables)
+                             int desired_program, int cardnum, bool cacheTables, DVBKind dvbkind)
     : MPEGStreamData(desired_program, cardnum, cacheTables),
-      m_desiredNetId(desired_netid), m_desiredTsId(desired_tsid)
+      m_desiredNetId(desired_netid), m_desiredTsId(desired_tsid),
+      _dvbkind(dvbkind),
+      m_dvbRealNetworkId(-1), m_dvbEitDishnetLong(false)
 {
     m_nitStatus.SetVersion(-1,0);
     m_nitoStatus.SetVersion(-1,0);
@@ -217,7 +219,7 @@ bool DVBStreamData::HandleTables(uint pi
         if ((psip.TableID() == TableID::NIT  && psip.TableIDExtension() != (uint)m_dvbRealNetworkId) ||
             (psip.TableID() == TableID::NITo && psip.TableIDExtension() == (uint)m_dvbRealNetworkId)  )
         {
-            auto *nit = new NetworkInformationTable(psip);
+            auto *nit = new NetworkInformationTable(psip, _dvbkind);
             if (!nit->Mutate())
             {
                 delete nit;
@@ -241,7 +243,7 @@ bool DVBStreamData::HandleTables(uint pi
 
             if (m_cacheTables)
             {
-                auto *nit = new NetworkInformationTable(psip);
+                auto *nit = new NetworkInformationTable(psip, _dvbkind);
                 CacheNIT(nit);
                 QMutexLocker locker(&m_listenerLock);
                 for (auto & listener : m_dvbMainListeners)
@@ -249,10 +251,12 @@ bool DVBStreamData::HandleTables(uint pi
             }
             else
             {
-                NetworkInformationTable nit(psip);
+                NetworkInformationTable nit(psip, _dvbkind);
                 QMutexLocker locker(&m_listenerLock);
                 for (auto & listener : m_dvbMainListeners)
                     listener->HandleNIT(&nit);
+//                for (size_t i = 0; i < _dvb_main_listeners.size(); i++)
+//                  _dvb_main_listeners[i]->HandleNIT(&nit);
             }
 
             return true;
@@ -265,13 +269,13 @@ bool DVBStreamData::HandleTables(uint pi
 
             if (m_cacheTables)
             {
-                auto *sdt = new ServiceDescriptionTable(psip);
+				auto *sdt = new ServiceDescriptionTable(psip, _dvbkind);
                 CacheSDT(sdt);
                 ProcessSDT(tsid, sdt);
             }
             else
             {
-                ServiceDescriptionTable sdt(psip);
+                ServiceDescriptionTable sdt(psip, _dvbkind);
                 ProcessSDT(tsid, &sdt);
             }
 
@@ -279,7 +283,7 @@ bool DVBStreamData::HandleTables(uint pi
         }
         case TableID::TDT:
         {
-            TimeDateTable tdt(psip);
+            TimeDateTable tdt(psip, _dvbkind);
 
             UpdateTimeOffset(tdt.UTCUnix());
 
@@ -293,7 +297,7 @@ bool DVBStreamData::HandleTables(uint pi
         {
             m_nitoStatus.SetSectionSeen(psip.Version(), psip.Section(),
                                         psip.LastSection());
-            NetworkInformationTable nit(psip);
+            NetworkInformationTable nit(psip, _dvbkind);
 
             QMutexLocker locker(&m_listenerLock);
             for (auto & listener : m_dvbOtherListeners)
@@ -306,14 +310,14 @@ bool DVBStreamData::HandleTables(uint pi
             uint tsid = psip.TableIDExtension();
             m_sdtoStatus.SetSectionSeen(tsid, psip.Version(), psip.Section(),
                                         psip.LastSection());
-            ServiceDescriptionTable sdt(psip);
+            ServiceDescriptionTable sdt(psip, _dvbkind);
 
             // some providers send the SDT for the current multiplex as SDTo
             // this routine changes the TableID to SDT and recalculates the CRC
             if (m_desiredNetId == sdt.OriginalNetworkID() &&
                 m_desiredTsId  == tsid)
             {
-                auto *sdta = new ServiceDescriptionTable(psip);
+				auto *sdta = new ServiceDescriptionTable(psip, _dvbkind);
                 if (!sdta->Mutate())
                 {
                     delete sdta;
@@ -379,9 +383,11 @@ bool DVBStreamData::HandleTables(uint pi
         m_eitStatus.SetSectionSeen(key, psip.Version(), psip.Section(),
                                     psip.LastSection());
 
-        DVBEventInformationTable eit(psip);
+        DVBEventInformationTable eit(psip, _dvbkind);
         for (auto & listener : m_dvbEitListeners)
             listener->HandleEIT(&eit);
+//       for (size_t i = 0; i < _dvb_eit_listeners.size(); i++)
+//            _dvb_eit_listeners[i]->HandleEIT(&eit);
 
         if (m_eitHelper)
             m_eitHelper->AddEIT(&eit);
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbstreamdata.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dvbstreamdata.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbstreamdata.h
@@ -33,7 +33,8 @@ class MTV_PUBLIC DVBStreamData : virtual
 {
   public:
     DVBStreamData(uint desired_netid, uint desired_tsid,
-                  int desired_program, int cardnum, bool cacheTables = false);
+                  int desired_program, int cardnum, bool cacheTables = false,
+				  DVBKind dvbkind = kKindDVB);
     ~DVBStreamData() override;
 
     using MPEGStreamData::Reset;
@@ -131,6 +132,7 @@ class MTV_PUBLIC DVBStreamData : virtual
     /// DVB table monitoring
     uint                      m_desiredNetId;
     uint                      m_desiredTsId;
+    DVBKind                   _dvbkind;
 
     // Real network ID for broken providers
     int                       m_dvbRealNetworkId { -1 };
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbtables.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dvbtables.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbtables.cpp
@@ -90,7 +90,7 @@ QString NetworkInformationTable::Network
 
         if (desc)
         {
-            auto nndesc = NetworkNameDescriptor(desc);
+            auto nndesc = NetworkNameDescriptor(desc, _dvbkind);
             if (nndesc.IsValid())
                 m_cachedNetworkName = nndesc.Name();
         }
@@ -171,7 +171,7 @@ ServiceDescriptor *ServiceDescriptionTab
         MPEGDescriptor::Find(parsed, DescriptorID::service);
 
     if (desc)
-        return new ServiceDescriptor(desc);
+        return new ServiceDescriptor(desc, _dvbkind);
 
     return nullptr;
 }
@@ -286,12 +286,20 @@ bool DVBEventInformationTable::IsEIT(uin
 /** \fn dvbdate2qt(const unsigned char*)
  *  \return UTC time as QDateTime
  */
-QDateTime dvbdate2qt(const unsigned char *buf)
+QDateTime dvbdate2qt(const unsigned char *buf, DVBKind dvbkind)
 {
     /* FIXME what's wrong with QDate::fromJulianDay? */
     uint mjd = (buf[0] << 8) | buf[1];
     if (mjd >= 40587)
     {
+        if (dvbkind == kKindISDB)
+        {
+            QDate date(1970, 1, 1);
+            QTime time(byteBCD2int(buf[2]), byteBCD2int(buf[3]),
+                       byteBCD2int(buf[4]));
+            return QDateTime(date.addDays(mjd - 40587), time).toUTC();
+        }
+
         // Modified Julian date as number of days since 17th November 1858.
         // 1st Jan 1970 was date 40587.
         uint secsSince1970 = (mjd - 40587)   * 86400;
@@ -325,13 +333,16 @@ QDateTime dvbdate2qt(const unsigned char
     QTime time(byteBCD2int(buf[2]), byteBCD2int(buf[3]),
                byteBCD2int(buf[4]));
 
-    return QDateTime(date, time, Qt::UTC);
+    if (dvbkind == kKindISDB)
+        return QDateTime(date, time, Qt::LocalTime).toUTC();
+    else
+        return QDateTime(date, time, Qt::UTC);
 }
 
 /** \fn dvbdate2unix(const unsigned char*)
  *  \return UTC time as time_t
  */
-time_t dvbdate2unix(const unsigned char *buf)
+time_t dvbdate2unix(const unsigned char *buf, DVBKind dvbkind)
 {
     // Modified Julian date as number of days since 17th November 1858.
     // The unix epoch, 1st Jan 1970, was day 40587.
@@ -339,6 +350,14 @@ time_t dvbdate2unix(const unsigned char
     if (mjd < 40587)
         return 0; // we don't handle pre-unix dates..
 
+    if (dvbkind == kKindISDB)
+    {
+        QDate date(1970, 1, 1);
+        QTime time(byteBCD2int(buf[2]), byteBCD2int(buf[3]),
+                   byteBCD2int(buf[4]));
+        return QDateTime(date.addDays(mjd - 40587), time).toUTC().toTime_t();
+    }
+
     uint secsSince1970 = (mjd - 40587)   * 86400;
     secsSince1970 += byteBCD2int(buf[2]) * 3600;
     secsSince1970 += byteBCD2int(buf[3]) * 60;
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbtables.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/dvbtables.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/dvbtables.h
@@ -10,25 +10,37 @@
 #include "mpegtables.h"
 #include "mythtvexp.h"
 
-MTV_PUBLIC QDateTime dvbdate2qt(const unsigned char *buf);
-MTV_PUBLIC time_t dvbdate2unix(const unsigned char *buf);
-uint32_t dvbdate2key(const unsigned char *buf);
+MTV_PUBLIC QDateTime dvbdate2qt(const unsigned char* buf, DVBKind dvbkind);
+MTV_PUBLIC time_t dvbdate2unix(const unsigned char* buf, DVBKind dvbkind);
+uint32_t dvbdate2key(const unsigned char* buf);
+
+class MTV_PUBLIC DVBTable : public PSIPTable
+{
+  public:
+    DVBTable(const PSIPTable& table, DVBKind dvbkind)
+        : PSIPTable(table), _dvbkind(dvbkind) {}
+    ~DVBTable() {}
+    DVBKind DVBKindStatus() const { return _dvbkind; }
+  protected:
+    DVBKind _dvbkind;
+};
 
 /** \class NetworkInformationTable
  *  \brief This table tells the decoder on which PIDs to find other tables.
  *  \todo This is just a stub.
  */
-class MTV_PUBLIC NetworkInformationTable : public PSIPTable
+//class MTV_PUBLIC NetworkInformationTable : public PSIPTable
+class MTV_PUBLIC NetworkInformationTable : public DVBTable
 {
   public:
-    NetworkInformationTable(const NetworkInformationTable& table)
-        : PSIPTable(table)
+    NetworkInformationTable(const NetworkInformationTable& table, DVBKind dvbkind)
+        : DVBTable(table, dvbkind)
     {
         assert(TableID::NIT == TableID() || TableID::NITo == TableID());
         Parse();
     }
-    explicit NetworkInformationTable(const PSIPTable& table)
-        : PSIPTable(table)
+    explicit NetworkInformationTable(const PSIPTable& table, DVBKind dvbkind)
+        : DVBTable(table, dvbkind)
     {
         assert(TableID::NIT == TableID() || TableID::NITo == TableID());
         Parse();
@@ -98,16 +110,16 @@ class MTV_PUBLIC NetworkInformationTable
  *  \brief This table tells the decoder on which PIDs to find A/V data.
  *  \todo This is just a stub.
  */
-class MTV_PUBLIC ServiceDescriptionTable : public PSIPTable
+class MTV_PUBLIC ServiceDescriptionTable : public DVBTable
 {
   public:
-    ServiceDescriptionTable(const ServiceDescriptionTable& table)
-        : PSIPTable(table)
+    ServiceDescriptionTable(const ServiceDescriptionTable& table, DVBKind dvbkind)
+        : DVBTable(table, dvbkind)
     {
         assert(TableID::SDT == TableID() || TableID::SDTo == TableID());
         Parse();
     }
-    explicit ServiceDescriptionTable(const PSIPTable& table) : PSIPTable(table)
+    explicit ServiceDescriptionTable(const PSIPTable& table, DVBKind dvbkind) : DVBTable(table, dvbkind)
     {
         assert(TableID::SDT == TableID() || TableID::SDTo == TableID());
         Parse();
@@ -282,10 +294,10 @@ class MTV_PUBLIC SelectionInformationTab
     // CRC_32 32 rpchof
 };
 
-class MTV_PUBLIC DVBEventInformationTable : public PSIPTable
+class MTV_PUBLIC DVBEventInformationTable : public DVBTable
 {
   public:
-    explicit DVBEventInformationTable(const PSIPTable& table) : PSIPTable(table)
+    explicit DVBEventInformationTable(const PSIPTable& table, DVBKind dvbkind) : DVBTable(table, dvbkind)
     {
     // table_id                 8   0.0       0xC7
         assert(IsEIT(TableID()));
@@ -329,9 +341,9 @@ class MTV_PUBLIC DVBEventInformationTabl
     const unsigned char *StartTime(uint i) const
         { return m_ptrs[i]+2; }
     QDateTime StartTimeUTC(uint i) const
-        { return dvbdate2qt(StartTime(i)); }
+        { return dvbdate2qt(StartTime(i), _dvbkind); }
     time_t StartTimeUnixUTC(uint i) const
-        { return dvbdate2unix(StartTime(i)); }
+        { return dvbdate2unix(StartTime(i), _dvbkind); }
     time_t EndTimeUnixUTC(uint i) const
         { return StartTimeUnixUTC(i) + DurationInSeconds(i); }
     uint32_t StartTimeKey(uint i) const
@@ -370,11 +382,11 @@ class MTV_PUBLIC DVBEventInformationTabl
 /** \class TimeDateTable
  *  \brief This table gives the current DVB stream time
  */
-class MTV_PUBLIC TimeDateTable : public PSIPTable
+class MTV_PUBLIC TimeDateTable : public DVBTable
 {
   public:
-    explicit TimeDateTable(const PSIPTable& table)
-        : PSIPTable(table)
+    explicit TimeDateTable(const PSIPTable& table, DVBKind dvbkind)
+        : DVBTable(table, dvbkind)
     {
         assert(TableID::TDT == TableID());
     }
@@ -389,8 +401,8 @@ class MTV_PUBLIC TimeDateTable : public
     const unsigned char *UTCdata(void) const
         { return pesdata() + 3; }
 
-    QDateTime UTC(void)  const { return dvbdate2qt(UTCdata());   }
-    time_t UTCUnix(void) const { return dvbdate2unix(UTCdata()); }
+    QDateTime UTC(void)  const { return dvbdate2qt(UTCdata(), _dvbkind);   }
+    time_t UTCUnix(void) const { return dvbdate2unix(UTCdata(), _dvbkind); }
 };
 
 #endif // _DVB_TABLES_H_
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/isdb_decode_text.c
===================================================================
--- /dev/null
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/isdb_decode_text.c
@@ -0,0 +1,1831 @@
+#include <stdlib.h>
+#include <assert.h>
+#include <errno.h>
+#include <iconv.h>
+
+/*#define USE_UNICODE_SQUAREDCJK	(1)*/
+/*#define DEBUG	(1)*/
+
+#ifdef DEBUG
+#include <stdio.h>
+#include <sys/time.h>
+#include <pthread.h>
+pthread_mutex_t mut = PTHREAD_MUTEX_INITIALIZER;
+#endif
+
+#include "isdb_decode_text.h"
+
+typedef struct {
+	ISDBTYPE isdb;
+
+	/* for ARIB STD-B24 8bit-character code */
+	iconv_t cd;
+} _IsdbDecode;
+
+typedef struct {
+	const unsigned char *str;
+	const unsigned char *p;
+	unsigned len;
+} IBUF;
+#define IBUF_init(ibuf, s, l)		{ (ibuf)->str = (ibuf)->p = (s); (ibuf)->len = (l); }
+#define IBUF_isremain(ibuf)			((ibuf)->p < (ibuf)->str + (ibuf)->len)
+#define IBUF_isremainn(ibuf, n)		((ibuf)->p + (n) < (ibuf)->str + (ibuf)->len)
+#define IBUF_get(ibuf)				(*(ibuf)->p++)
+#define IBUF_geti(ibuf, i)			((ibuf)->p[(i)])
+
+typedef struct {
+	unsigned char *str;
+	unsigned char *p;
+	unsigned len;
+} OBUF;
+#define OBUF_init(obuf, s, l)		{ (obuf)->str = (obuf)->p = (s); (obuf)->len = (l); }
+#define OBUF_isremain(obuf)			((obuf)->p + 1 <= (obuf)->str + (obuf)->len)
+#define OBUF_isremainn(obuf, n)		((obuf)->p + (n) <= (obuf)->str + (obuf)->len)
+#define OBUF_put(obuf, c)			{ *(obuf)->p++ = (c); }
+#define OBUF_putp(obuf)				(&(obuf)->p)
+#define OBUF_putleft(obuf)			((obuf)->str + (obuf)->len - (obuf)->p)
+
+/* ARIB STD-B24 Table 7-14 */
+#define SP		(0x20)
+
+#define APD		(0x0a)
+#define LS1		(0x0e)
+#define LS0		(0x0f)
+#define PAPF	(0x16)
+#define SS2		(0x19)
+#define ESC		(0x1b)
+#define APS		(0x1c)
+#define SS3		(0x1d)
+
+#define SZX		(0x8b)
+#define COL		(0x90)
+#define FLC		(0x91)
+#define CDC		(0x92)
+#define POL		(0x93)
+#define WMM		(0x94)
+#define MACRO	(0x95)
+#define HLC		(0x97)
+#define RPC		(0x98)
+#define CSI		(0x9b)
+#define TIME	(0x9d)
+
+/* ARIB STD-B24 Table 7-1 */
+#define LS2_2	(0x6e)
+#define LS3_2	(0x6f)
+#define LS1R_2	(0x7e)
+#define LS2R_2	(0x7d)
+#define LS3R_2	(0x7c)
+
+/* ARIB STD-B24 Table 7-2 */
+#define GSET1BYTE_2_G0	(0x28)
+#define GSET1BYTE_2_G1	(0x29)
+#define GSET1BYTE_2_G2	(0x2a)
+#define GSET1BYTE_2_G3	(0x2b)
+#define GSET2BYTE_2		(0x24)
+#define GSET2BYTE_3_G1	(0x29)
+#define GSET2BYTE_3_G2	(0x2a)
+#define GSET2BYTE_3_G3	(0x2b)
+#define DRCS1BYTE_3		(0x20)	/* non-support */
+#define DRCS2BYTE_3_G0	(0x28)	/* non-support */
+#define DRCS2BYTE_4		(0x20)	/* non-support */
+
+/* ARIB STD-B24 Table 7-3 */
+#define CODESET_KANJI				(0x42)	/* 2byte */
+#define CODESET_ALPHANUMERIC		(0x4a)
+#define CODESET_HIRAGANA			(0x30)
+#define CODESET_KATAKANA			(0x31)
+#define CODESET_MOSAIC_A			(0x32)	/* non-support */
+#define CODESET_MOSAIC_B			(0x33)	/* non-support */
+#define CODESET_MOSAIC_C			(0x34)	/* non-support */
+#define CODESET_MOSAIC_D			(0x35)	/* non-support */
+#define CODESET_P_ALPHANUMERIC		(0x36)
+#define CODESET_P_HIRAGANA			(0x37)
+#define CODESET_P_KATAKANA			(0x38)
+#define CODESET_JISX0201KATAKANA	(0x49)
+#define CODESET_JIS_KANJI1			(0x39)	/* 2byte */
+#define CODESET_JIS_KANJI2			(0x3a)	/* 2byte */
+#define CODESET_ADDITIONAL_SYMBOLS	(0x3b)	/* 2byte */
+
+/* ABNT NBR 15606-1 Table 15 */
+#define CODESET_LATIN_EXTENSION		(0x4b)	/* non-support */
+#define CODESET_SPECIAL_CHARACTER	(0x4c)	/* non-support */
+
+#define ISGL(c)	(0x21 <= (c) && (c) <= 0x7e)
+#define ISGR(c)	(0xa1 <= (c) && (c) <= 0xfe)
+#define ISADDITIONAL_SYMBOLS(row)	(90 <= row && row <= 94)
+#define ISADDITIONAL_KANJI(row)		(85 <= row && row <= 86)
+
+typedef enum { GLRnull, GL, GR } GLR;
+typedef enum { Gnull, G0, G1, G2, G3, } GSET;
+typedef enum {
+	Cnull, Ckanji,
+	Calpha, Chiragana, Ckatakana,
+	CPalpha, CPhiragana, CPkatakana,
+	CJkatakana, CJkanji1, CJkanji2, Cadd,
+	Cextension, Cspecial,
+} CODESET;
+
+typedef struct {
+	GSET gl;					/* GL: locking shift */
+	GSET gr;					/* GR: locking shift */
+	GSET ss;					/* GL: single shift */
+	CODESET g0, g1, g2, g3;
+} SELECTINFO;
+
+#define REPLACEMENT_CHARACTER "\xef\xbf\xbd"
+
+static const char codeset_Alphanumeric[93] =
+	"!\"#$%&'()*+,-./"
+	"0123456789:;<=>?"
+	"@ABCDEFGHIJKLMNO"
+	"PQRSTUVWXYZ[\xa5]^_"
+	"`abcdefghijklmno"
+	"pqrstuvwxyz{|}"	/* 0x7e: over line U+203E=\xe2\x80\xbe */
+	;
+
+static const char codeset_Hiragana[94*3] =
+	"ぁあぃいぅうぇえぉおかがきぎく"
+	"ぐけげこごさざしじすずせぜそぞた"
+	"だちぢっつづてでとどなにぬねのは"
+	"ばぱひびぴふぶぷへべぺほぼぽまみ"
+	"むめもゃやゅゆょよらりるれろゎわ"
+	"ゐゑをん　　　ゝゞー。「」、・"
+	;
+
+static const char codeset_Katakana[94*3] =
+	"ァアィイゥウェエォオカガキギク"
+	"グケゲコゴサザシジスズセゼソゾタ"
+	"ダチヂッツヅテデトドナニヌネノハ"
+	"バパヒビピフブプヘベペホボポマミ"
+	"ムメモャヤュユョヨラリルレロヮワ"
+	"ヰヱヲンヴヵヶヽヾー。「」、・"
+	;
+
+static const char codeset_JISX0201katakana[63*3] =
+	"｡｢｣､･ｦｧｨｩｪｫｬｭｮｯ"
+	"ｰｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿ"
+	"ﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏ"
+	"ﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝﾞﾟ"
+	;
+
+/* Additional symbols */
+static const char * const codeset_Additional_symbols90[5][94] = {
+	{
+		/* row:90 */
+		"\xe2\x9b\x8c",	/* cell:1 */
+		"\xe2\x9b\x8d",	/* cell:2 */
+		"\xe2\x9d\x97",	/* cell:3 */
+		"\xe2\x9b\x8f",	/* cell:4 */
+		"\xe2\x9b\x90",	/* cell:5 */
+		"\xe2\x9b\x91",	/* cell:6 */
+		REPLACEMENT_CHARACTER,	/* cell:7 */
+		"\xe2\x9b\x92",	/* cell:8 */
+		"\xe2\x9b\x95",	/* cell:9 */
+		"\xe2\x9b\x93",	/* cell:10 */
+		"\xe2\x9b\x94",	/* cell:11 */
+		REPLACEMENT_CHARACTER,	/* cell:12 */
+		REPLACEMENT_CHARACTER,	/* cell:13 */
+		REPLACEMENT_CHARACTER,	/* cell:14 */
+		REPLACEMENT_CHARACTER,	/* cell:15 */
+		"\xf0\x9f\x85\xbf",	/* cell:16 */
+		"\xf0\x9f\x86\x8a",	/* cell:17 */
+		REPLACEMENT_CHARACTER,	/* cell:18 */
+		REPLACEMENT_CHARACTER,	/* cell:19 */
+		"\xe2\x9b\x96",	/* cell:20 */
+		"\xe2\x9b\x97",	/* cell:21 */
+		"\xe2\x9b\x98",	/* cell:22 */
+		"\xe2\x9b\x99",	/* cell:23 */
+		"\xe2\x9b\x9a",	/* cell:24 */
+		"\xe2\x9b\x9b",	/* cell:25 */
+		"\xe2\x9b\x9c",	/* cell:26 */
+		"\xe2\x9b\x9d",	/* cell:27 */
+		"\xe2\x9b\x9e",	/* cell:28 */
+		"\xe2\x9b\x9f",	/* cell:29 */
+		"\xe2\x9b\xa0",	/* cell:30 */
+		"\xe2\x9b\xa1",	/* cell:31 */
+		"\xe2\xad\x95",	/* cell:32 */
+		"\xe3\x89\x88",	/* cell:33 */
+		"\xe3\x89\x89",	/* cell:34 */
+		"\xe3\x89\x8a",	/* cell:35 */
+		"\xe3\x89\x8b",	/* cell:36 */
+		"\xe3\x89\x8c",	/* cell:37 */
+		"\xe3\x89\x8d",	/* cell:38 */
+		"\xe3\x89\x8e",	/* cell:39 */
+		"\xe3\x89\x8f",	/* cell:40 */
+		REPLACEMENT_CHARACTER,	/* cell:41 */
+		REPLACEMENT_CHARACTER,	/* cell:42 */
+		REPLACEMENT_CHARACTER,	/* cell:43 */
+		REPLACEMENT_CHARACTER,	/* cell:44 */
+		"\xe2\x92\x91",	/* cell:45 */
+		"\xe2\x92\x92",	/* cell:46 */
+		"\xe2\x92\x93",	/* cell:47 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x85\x8a",	/* cell:48 */
+		"\xf0\x9f\x85\x8c",	/* cell:49 */
+		"\xf0\x9f\x84\xbf",	/* cell:50 */
+		"\xf0\x9f\x85\x86",	/* cell:51 */
+		"\xf0\x9f\x85\x8b",	/* cell:52 */
+		"\xf0\x9f\x88\x90",	/* cell:53 */
+		"\xf0\x9f\x88\x91",	/* cell:54 */
+		"\xf0\x9f\x88\x92",	/* cell:55 */
+		"\xf0\x9f\x88\x93",	/* cell:56 */
+		"\xf0\x9f\x85\x82",	/* cell:57 */
+		"\xf0\x9f\x88\x94",	/* cell:58 */
+		"\xf0\x9f\x88\x95",	/* cell:59 */
+		"\xf0\x9f\x88\x96",	/* cell:60 */
+		"\xf0\x9f\x85\x8d",	/* cell:61 */
+		"\xf0\x9f\x84\xb1",	/* cell:62 */
+		"\xf0\x9f\x84\xbd",	/* cell:63 */
+#else
+		"[HV]",	/* cell:48 */
+		"[SD]",	/* cell:49 */
+		"[P]",	/* cell:50 */
+		"[W]",	/* cell:51 */
+		"[MV]",	/* cell:52 */
+		"[\xe6\x89\x8b]",	/* cell:53 */
+		"[\xe5\xad\x97]",	/* cell:54 */
+		"[\xe5\x8f\x8c]",	/* cell:55 */
+		"[\xe3\x83\x87]",	/* cell:56 */
+		"[S]",	/* cell:57 */
+		"[\xe4\xba\x8c]",	/* cell:58 */
+		"[\xe5\xa4\x9a]",	/* cell:59 */
+		"[\xe8\xa7\xa3]",	/* cell:60 */
+		"[SS]",	/* cell:61 */
+		"[B]",	/* cell:62 */
+		"[N]",	/* cell:63 */
+#endif
+		"\xe2\xac\x9b",	/* cell:64 */
+		"\xe2\xac\xa4",	/* cell:65 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x88\x97",	/* cell:66 */
+		"\xf0\x9f\x88\x98",	/* cell:67 */
+		"\xf0\x9f\x88\x99",	/* cell:68 */
+		"\xf0\x9f\x88\x9a",	/* cell:69 */
+		"\xf0\x9f\x88\x9b",	/* cell:70 */
+#else
+		"[\xe5\xa4\xa9]",	/* cell:66 */
+		"[\xe4\xba\xa4]",	/* cell:67 */
+		"[\xe6\x98\xa0]",	/* cell:68 */
+		"[\xe7\x84\xa1]",	/* cell:69 */
+		"[\xe6\x96\x99]",	/* cell:70 */
+#endif
+		"\xe2\x9a\xbf",	/* cell:71 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x88\x9c",	/* cell:72 */
+		"\xf0\x9f\x88\x9d",	/* cell:73 */
+		"\xf0\x9f\x88\x9e",	/* cell:74 */
+		"\xf0\x9f\x88\x9f",	/* cell:75 */
+		"\xf0\x9f\x88\xa0",	/* cell:76 */
+		"\xf0\x9f\x88\xa1",	/* cell:77 */
+		"\xf0\x9f\x88\xa2",	/* cell:78 */
+		"\xf0\x9f\x88\xa3",	/* cell:79 */
+		"\xf0\x9f\x88\xa4",	/* cell:80 */
+		"\xf0\x9f\x88\xa5",	/* cell:81 */
+		"\xf0\x9f\x85\x8e",	/* cell:82 */
+#else
+		"[\xe5\x89\x8d]",	/* cell:72 */
+		"[\xe5\xbe\x8c]",	/* cell:73 */
+		"[\xe5\x86\x8d]",	/* cell:74 */
+		"[\xe6\x96\xb0]",	/* cell:75 */
+		"[\xe5\x88\x9d]",	/* cell:76 */
+		"[\xe7\xb5\x82]",	/* cell:77 */
+		"[\xe7\x94\x9f]",	/* cell:78 */
+		"[\xe8\xb2\xa9]",	/* cell:79 */
+		"[\xe5\xa3\xb0]",	/* cell:80 */
+		"[\xe5\x90\xb9]",	/* cell:81 */
+		"[PPV]",	/* cell:82 */
+#endif
+		"\xe3\x8a\x99",	/* cell:83 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x88\x80",	/* cell:84 */
+#else
+		"\xe3\x81\xbb\xe3\x81\x8b",	/* cell:84 */
+#endif
+		REPLACEMENT_CHARACTER,	/* cell:85 */
+		REPLACEMENT_CHARACTER,	/* cell:86 */
+		REPLACEMENT_CHARACTER,	/* cell:87 */
+		REPLACEMENT_CHARACTER,	/* cell:88 */
+		REPLACEMENT_CHARACTER,	/* cell:89 */
+		REPLACEMENT_CHARACTER,	/* cell:90 */
+		REPLACEMENT_CHARACTER,	/* cell:91 */
+		REPLACEMENT_CHARACTER,	/* cell:92 */
+		REPLACEMENT_CHARACTER,	/* cell:93 */
+		REPLACEMENT_CHARACTER,	/* cell:94 */
+	}, {
+		/* row:91 */
+		"\xe2\x9b\xa3",	/* cell:1 */
+		"\xe2\xad\x96",	/* cell:2 */
+		"\xe2\xad\x97",	/* cell:3 */
+		"\xe2\xad\x98",	/* cell:4 */
+		"\xe2\xad\x99",	/* cell:5 */
+		"\xe2\x98\x93",	/* cell:6 */
+		"\xe3\x8a\x8b",	/* cell:7 */
+		"\xe3\x80\x92",	/* cell:8 */
+		"\xe2\x9b\xa8",	/* cell:9 */
+		"\xe3\x89\x86",	/* cell:10 */
+		"\xe3\x89\x85",	/* cell:11 */
+		"\xe2\x9b\xa9",	/* cell:12 */
+		"\xe5\x8d\x8d",	/* cell:13 */
+		"\xe2\x9b\xaa",	/* cell:14 */
+		"\xe2\x9b\xab",	/* cell:15 */
+		"\xe2\x9b\xac",	/* cell:16 */
+		"\xe2\x99\xa8",	/* cell:17 */
+		"\xe2\x9b\xad",	/* cell:18 */
+		"\xe2\x9b\xae",	/* cell:19 */
+		"\xe2\x9b\xaf",	/* cell:20 */
+		"\xe2\x9a\x93",	/* cell:21 */
+		"\xe2\x9c\x88",	/* cell:22 */
+		"\xe2\x9b\xb0",	/* cell:23 */
+		"\xe2\x9b\xb1",	/* cell:24 */
+		"\xe2\x9b\xb2",	/* cell:25 */
+		"\xe2\x9b\xb3",	/* cell:26 */
+		"\xe2\x9b\xb4",	/* cell:27 */
+		"\xe2\x9b\xb5",	/* cell:28 */
+		"\xf0\x9f\x85\x97",	/* cell:29 */
+		"\xe2\x92\xb9",	/* cell:30 */
+		"\xe2\x93\x88",	/* cell:31 */
+		"\xe2\x9b\xb6",	/* cell:32 */
+		"\xf0\x9f\x85\x9f",	/* cell:33 */
+		"\xf0\x9f\x86\x8b",	/* cell:34 */
+		"\xf0\x9f\x86\x8d",	/* cell:35 */
+		"\xf0\x9f\x86\x8c",	/* cell:36 */
+		"\xf0\x9f\x85\xb9",	/* cell:37 */
+		"\xe2\x9b\xb7",	/* cell:38 */
+		"\xe2\x9b\xb8",	/* cell:39 */
+		"\xe2\x9b\xb9",	/* cell:40 */
+		"\xe2\x9b\xba",	/* cell:41 */
+		"\xf0\x9f\x85\xbb",	/* cell:42 */
+		"\xe2\x98\x8e",	/* cell:43 */
+		"\xe2\x9b\xbb",	/* cell:44 */
+		"\xe2\x9b\xbc",	/* cell:45 */
+		"\xe2\x9b\xbd",	/* cell:46 */
+		"\xe2\x9b\xbe",	/* cell:47 */
+		"\xf0\x9f\x85\xbc",	/* cell:48 */
+		"\xe2\x9b\xbf",	/* cell:49 */
+		REPLACEMENT_CHARACTER,	/* cell:50 */
+		REPLACEMENT_CHARACTER,	/* cell:51 */
+		REPLACEMENT_CHARACTER,	/* cell:52 */
+		REPLACEMENT_CHARACTER,	/* cell:53 */
+		REPLACEMENT_CHARACTER,	/* cell:54 */
+		REPLACEMENT_CHARACTER,	/* cell:55 */
+		REPLACEMENT_CHARACTER,	/* cell:56 */
+		REPLACEMENT_CHARACTER,	/* cell:57 */
+		REPLACEMENT_CHARACTER,	/* cell:58 */
+		REPLACEMENT_CHARACTER,	/* cell:59 */
+		REPLACEMENT_CHARACTER,	/* cell:60 */
+		REPLACEMENT_CHARACTER,	/* cell:61 */
+		REPLACEMENT_CHARACTER,	/* cell:62 */
+		REPLACEMENT_CHARACTER,	/* cell:63 */
+		REPLACEMENT_CHARACTER,	/* cell:64 */
+		REPLACEMENT_CHARACTER,	/* cell:65 */
+		REPLACEMENT_CHARACTER,	/* cell:66 */
+		REPLACEMENT_CHARACTER,	/* cell:67 */
+		REPLACEMENT_CHARACTER,	/* cell:68 */
+		REPLACEMENT_CHARACTER,	/* cell:69 */
+		REPLACEMENT_CHARACTER,	/* cell:70 */
+		REPLACEMENT_CHARACTER,	/* cell:71 */
+		REPLACEMENT_CHARACTER,	/* cell:72 */
+		REPLACEMENT_CHARACTER,	/* cell:73 */
+		REPLACEMENT_CHARACTER,	/* cell:74 */
+		REPLACEMENT_CHARACTER,	/* cell:75 */
+		REPLACEMENT_CHARACTER,	/* cell:76 */
+		REPLACEMENT_CHARACTER,	/* cell:77 */
+		REPLACEMENT_CHARACTER,	/* cell:78 */
+		REPLACEMENT_CHARACTER,	/* cell:79 */
+		REPLACEMENT_CHARACTER,	/* cell:80 */
+		REPLACEMENT_CHARACTER,	/* cell:81 */
+		REPLACEMENT_CHARACTER,	/* cell:82 */
+		REPLACEMENT_CHARACTER,	/* cell:83 */
+		REPLACEMENT_CHARACTER,	/* cell:84 */
+		REPLACEMENT_CHARACTER,	/* cell:85 */
+		REPLACEMENT_CHARACTER,	/* cell:86 */
+		REPLACEMENT_CHARACTER,	/* cell:87 */
+		REPLACEMENT_CHARACTER,	/* cell:88 */
+		REPLACEMENT_CHARACTER,	/* cell:89 */
+		REPLACEMENT_CHARACTER,	/* cell:90 */
+		REPLACEMENT_CHARACTER,	/* cell:91 */
+		REPLACEMENT_CHARACTER,	/* cell:92 */
+		REPLACEMENT_CHARACTER,	/* cell:93 */
+		REPLACEMENT_CHARACTER,	/* cell:94 */
+	}, {
+		/* row:92 */
+		"\xe2\x9e\xa1",	/* cell:1 */
+		"\xe2\xac\x85",	/* cell:2 */
+		"\xe2\xac\x86",	/* cell:3 */
+		"\xe2\xac\x87",	/* cell:4 */
+		"\xe2\xac\xaf",	/* cell:5 */
+		"\xe2\xac\xae",	/* cell:6 */
+		"\xe5\xb9\xb4",	/* cell:7 */
+		"\xe6\x9c\x88",	/* cell:8 */
+		"\xe6\x97\xa5",	/* cell:9 */
+		"\xe5\x86\x86",	/* cell:10 */
+		"\xe3\x8e\xa1",	/* cell:11 */
+		"\xe3\x8e\xa5",	/* cell:12 */
+		"\xe3\x8e\x9d",	/* cell:13 */
+		"\xe3\x8e\xa0",	/* cell:14 */
+		"\xe3\x8e\xa4",	/* cell:15 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x84\x80",	/* cell:16 */
+#else
+		"0.",	/* cell:16 */
+#endif
+		"\xe2\x92\x88",	/* cell:17 */
+		"\xe2\x92\x89",	/* cell:18 */
+		"\xe2\x92\x8a",	/* cell:19 */
+		"\xe2\x92\x8b",	/* cell:20 */
+		"\xe2\x92\x8c",	/* cell:21 */
+		"\xe2\x92\x8d",	/* cell:22 */
+		"\xe2\x92\x8e",	/* cell:23 */
+		"\xe2\x92\x8f",	/* cell:24 */
+		"\xe2\x92\x90",	/* cell:25 */
+		"\xee\x8a\x90",	/* cell:26 */
+		"\xee\x8a\x91",	/* cell:27 */
+		"\xee\x8a\x92",	/* cell:28 */
+		"\xee\x8a\x93",	/* cell:29 */
+		"\xee\x8a\x94",	/* cell:30 */
+		"\xee\x8a\x95",	/* cell:31 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x84\x81",	/* cell:32 */
+		"\xf0\x9f\x84\x82",	/* cell:33 */
+		"\xf0\x9f\x84\x83",	/* cell:34 */
+		"\xf0\x9f\x84\x84",	/* cell:35 */
+		"\xf0\x9f\x84\x85",	/* cell:36 */
+		"\xf0\x9f\x84\x86",	/* cell:37 */
+		"\xf0\x9f\x84\x87",	/* cell:38 */
+		"\xf0\x9f\x84\x88",	/* cell:39 */
+		"\xf0\x9f\x84\x89",	/* cell:40 */
+		"\xf0\x9f\x84\x8a",	/* cell:41 */
+#else
+		"0,",	/* cell:32 */
+		"1,",	/* cell:33 */
+		"2,",	/* cell:34 */
+		"3,",	/* cell:35 */
+		"4,",	/* cell:36 */
+		"5,",	/* cell:37 */
+		"6,",	/* cell:38 */
+		"7,",	/* cell:39 */
+		"8,",	/* cell:40 */
+		"9,",	/* cell:41 */
+#endif
+		"\xe3\x88\xb3",	/* cell:42 */
+		"\xe3\x88\xb6",	/* cell:43 */
+		"\xe3\x88\xb2",	/* cell:44 */
+		"\xe3\x88\xb1",	/* cell:45 */
+		"\xe3\x88\xb9",	/* cell:46 */
+		"\xe3\x89\x84",	/* cell:47 */
+		"\xe2\x96\xb6",	/* cell:48 */
+		"\xe2\x97\x80",	/* cell:49 */
+		"\xe3\x80\x96",	/* cell:50 */
+		"\xe3\x80\x97",	/* cell:51 */
+		"\xe2\x9f\x90",	/* cell:52 */
+		"\xc2\xb2",	/* cell:53 */
+		"\xc2\xb3",	/* cell:54 */
+		"\xf0\x9f\x84\xad",	/* cell:55 */
+		"\xee\x8a\xa5",	/* cell:56 */
+		"\xee\x8a\xa6",	/* cell:57 */
+		"\xee\x8a\xa7",	/* cell:58 */
+		"\xee\x8a\xa8",	/* cell:59 */
+		"\xee\x8a\xa9",	/* cell:60 */
+		"\xee\x8a\xaa",	/* cell:61 */
+		"\xee\x8a\xab",	/* cell:62 */
+		"\xee\x8a\xac",	/* cell:63 */
+		"\xee\x8a\xad",	/* cell:64 */
+		"\xee\x8a\xae",	/* cell:65 */
+		"\xee\x8a\xaf",	/* cell:66 */
+		"\xee\x8a\xb0",	/* cell:67 */
+		"\xee\x8a\xb1",	/* cell:68 */
+		"\xee\x8a\xb2",	/* cell:69 */
+		"\xee\x8a\xb3",	/* cell:70 */
+		"\xee\x8a\xb4",	/* cell:71 */
+		"\xee\x8a\xb5",	/* cell:72 */
+		"\xee\x8a\xb6",	/* cell:73 */
+		"\xee\x8a\xb7",	/* cell:74 */
+		"\xee\x8a\xb8",	/* cell:75 */
+		"\xee\x8a\xb9",	/* cell:76 */
+		"\xee\x8a\xba",	/* cell:77 */
+		"\xee\x8a\xbb",	/* cell:78 */
+		"\xee\x8a\xbc",	/* cell:79 */
+		"\xee\x8a\xbd",	/* cell:80 */
+		"\xee\x8a\xbe",	/* cell:81 */
+		"\xee\x8a\xbf",	/* cell:82 */
+		"\xee\x8b\x80",	/* cell:83 */
+		"\xee\x8b\x81",	/* cell:84 */
+		"\xee\x8b\x82",	/* cell:85 */
+		"\xf0\x9f\x84\xac",	/* cell:86 */
+		"\xf0\x9f\x84\xab",	/* cell:87 */
+		"\xe3\x89\x87",	/* cell:88 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x86\x90",	/* cell:89 */
+		"\xf0\x9f\x88\xa6",	/* cell:90 */
+#else
+		"DJ",	/* cell:89 */
+		"[\xe6\xbc\x94]",	/* cell:90 */
+#endif
+		"\xe2\x84\xbb",	/* cell:91 */
+		REPLACEMENT_CHARACTER,	/* cell:92 */
+		REPLACEMENT_CHARACTER,	/* cell:93 */
+		REPLACEMENT_CHARACTER,	/* cell:94 */
+	}, {
+		/* row:93 */
+		"\xe3\x88\xaa",	/* cell:1 */
+		"\xe3\x88\xab",	/* cell:2 */
+		"\xe3\x88\xac",	/* cell:3 */
+		"\xe3\x88\xad",	/* cell:4 */
+		"\xe3\x88\xae",	/* cell:5 */
+		"\xe3\x88\xaf",	/* cell:6 */
+		"\xe3\x88\xb0",	/* cell:7 */
+		"\xe3\x88\xb7",	/* cell:8 */
+		"\xe3\x8d\xbe",	/* cell:9 */
+		"\xe3\x8d\xbd",	/* cell:10 */
+		"\xe3\x8d\xbc",	/* cell:11 */
+		"\xe3\x8d\xbb",	/* cell:12 */
+		"\xe2\x84\x96",	/* cell:13 */
+		"\xe2\x84\xa1",	/* cell:14 */
+		"\xe3\x80\xb6",	/* cell:15 */
+		"\xe2\x9a\xbe",	/* cell:16 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x89\x80",	/* cell:17 */
+		"\xf0\x9f\x89\x81",	/* cell:18 */
+		"\xf0\x9f\x89\x82",	/* cell:19 */
+		"\xf0\x9f\x89\x83",	/* cell:20 */
+		"\xf0\x9f\x89\x84",	/* cell:21 */
+		"\xf0\x9f\x89\x85",	/* cell:22 */
+		"\xf0\x9f\x89\x86",	/* cell:23 */
+		"\xf0\x9f\x89\x87",	/* cell:24 */
+		"\xf0\x9f\x89\x88",	/* cell:25 */
+		"\xf0\x9f\x84\xaa",	/* cell:26 */
+		"\xf0\x9f\x88\xa7",	/* cell:27 */
+		"\xf0\x9f\x88\xa8",	/* cell:28 */
+		"\xf0\x9f\x88\xa9",	/* cell:29 */
+		"\xf0\x9f\x88\x94",	/* cell:30 */
+		"\xf0\x9f\x88\xaa",	/* cell:31 */
+		"\xf0\x9f\x88\xab",	/* cell:32 */
+		"\xf0\x9f\x88\xac",	/* cell:33 */
+		"\xf0\x9f\x88\xad",	/* cell:34 */
+		"\xf0\x9f\x88\xae",	/* cell:35 */
+		"\xf0\x9f\x88\xaf",	/* cell:36 */
+		"\xf0\x9f\x88\xb0",	/* cell:37 */
+		"\xf0\x9f\x88\xb1",	/* cell:38 */
+#else
+		"[\xe6\x9c\xac]",	/* cell:17 */
+		"[\xe4\xb8\x89]",	/* cell:18 */
+		"[\xe4\xba\x8c]",	/* cell:19 */
+		"[\xe5\xae\x89]",	/* cell:20 */
+		"[\xe7\x82\xb9]",	/* cell:21 */
+		"[\xe6\x89\x93]",	/* cell:22 */
+		"[\xe7\x9b\x97]",	/* cell:23 */
+		"[\xe5\x8b\x9d]",	/* cell:24 */
+		"[\xe6\x95\x97]",	/* cell:25 */
+		"[S]",	/* cell:26 */
+		"[\xe6\x8a\x95]",	/* cell:27 */
+		"[\xe6\x8d\x95]",	/* cell:28 */
+		"[\xe4\xb8\x80]",	/* cell:29 */
+		"[\xe4\xba\x8c]",	/* cell:30 */
+		"[\xe4\xb8\x89]",	/* cell:31 */
+		"[\xe9\x81\x8a]",	/* cell:32 */
+		"[\xe5\xb7\xa6]",	/* cell:33 */
+		"[\xe4\xb8\xad]",	/* cell:34 */
+		"[\xe5\x8f\xb3]",	/* cell:35 */
+		"[\xe6\x8c\x87]",	/* cell:36 */
+		"[\xe8\xb5\xb0]",	/* cell:37 */
+		"[\xe6\x89\x93]",	/* cell:38 */
+#endif
+		"\xe2\x84\x93",	/* cell:39 */
+		"\xe3\x8e\x8f",	/* cell:40 */
+		"\xe3\x8e\x90",	/* cell:41 */
+		"\xe3\x8f\x8a",	/* cell:42 */
+		"\xe3\x8e\x9e",	/* cell:43 */
+		"\xe3\x8e\xa2",	/* cell:44 */
+		"\xe3\x8d\xb1",	/* cell:45 */
+		REPLACEMENT_CHARACTER,	/* cell:46 */
+		REPLACEMENT_CHARACTER,	/* cell:47 */
+		"\xc2\xbd",	/* cell:48 */
+		"\xe2\x86\x89",	/* cell:49 */
+		"\xe2\x85\x93",	/* cell:50 */
+		"\xe2\x85\x94",	/* cell:51 */
+		"\xc2\xbc",	/* cell:52 */
+		"\xc2\xbe",	/* cell:53 */
+		"\xe2\x85\x95",	/* cell:54 */
+		"\xe2\x85\x96",	/* cell:55 */
+		"\xe2\x85\x97",	/* cell:56 */
+		"\xe2\x85\x98",	/* cell:57 */
+		"\xe2\x85\x99",	/* cell:58 */
+		"\xe2\x85\x9a",	/* cell:59 */
+		"\xe2\x85\x90",	/* cell:60 */
+		"\xe2\x85\x9b",	/* cell:61 */
+		"\xe2\x85\x91",	/* cell:62 */
+		"\xe2\x85\x92",	/* cell:63 */
+		"\xe2\x98\x80",	/* cell:64 */
+		"\xe2\x98\x81",	/* cell:65 */
+		"\xe2\x98\x82",	/* cell:66 */
+		"\xe2\x9b\x84",	/* cell:67 */
+		"\xe2\x98\x96",	/* cell:68 */
+		"\xe2\x98\x97",	/* cell:69 */
+		"\xe2\x9b\x89",	/* cell:70 */
+		"\xe2\x9b\x8a",	/* cell:71 */
+		"\xe2\x99\xa6",	/* cell:72 */
+		"\xe2\x99\xa5",	/* cell:73 */
+		"\xe2\x99\xa3",	/* cell:74 */
+		"\xe2\x99\xa0",	/* cell:75 */
+		"\xe2\x9b\x8b",	/* cell:76 */
+		"\xe2\x98\x89",	/* cell:77 */
+		"\xe2\x80\xbc",	/* cell:78 */
+		"\xe2\x81\x89",	/* cell:79 */
+		"\xe2\x9b\x85",	/* cell:80 */
+		"\xe2\x98\x94",	/* cell:81 */
+		"\xe2\x9b\x86",	/* cell:82 */
+		"\xe2\x98\x83",	/* cell:83 */
+		"\xe2\x9b\x87",	/* cell:84 */
+		"\xe2\x98\x87",	/* cell:85 */
+		"\xe2\x9b\x88",	/* cell:86 */
+		REPLACEMENT_CHARACTER,	/* cell:87 */
+		"\xe2\x9a\x9e",	/* cell:88 */
+		"\xe2\x9a\x9f",	/* cell:89 */
+		"\xe2\x99\xac",	/* cell:90 */
+		"\xe2\x98\x8e",	/* cell:91 */
+		REPLACEMENT_CHARACTER,	/* cell:92 */
+		REPLACEMENT_CHARACTER,	/* cell:93 */
+		REPLACEMENT_CHARACTER,	/* cell:94 */
+	}, {
+		/* row:94 */
+		"\xe2\x85\xa0",	/* cell:1 */
+		"\xe2\x85\xa1",	/* cell:2 */
+		"\xe2\x85\xa2",	/* cell:3 */
+		"\xe2\x85\xa3",	/* cell:4 */
+		"\xe2\x85\xa4",	/* cell:5 */
+		"\xe2\x85\xa5",	/* cell:6 */
+		"\xe2\x85\xa6",	/* cell:7 */
+		"\xe2\x85\xa7",	/* cell:8 */
+		"\xe2\x85\xa8",	/* cell:9 */
+		"\xe2\x85\xa9",	/* cell:10 */
+		"\xe2\x85\xaa",	/* cell:11 */
+		"\xe2\x85\xab",	/* cell:12 */
+		"\xe2\x91\xb0",	/* cell:13 */
+		"\xe2\x91\xb1",	/* cell:14 */
+		"\xe2\x91\xb2",	/* cell:15 */
+		"\xe2\x91\xb3",	/* cell:16 */
+		"\xe2\x91\xb4",	/* cell:17 */
+		"\xe2\x91\xb5",	/* cell:18 */
+		"\xe2\x91\xb6",	/* cell:19 */
+		"\xe2\x91\xb7",	/* cell:20 */
+		"\xe2\x91\xb8",	/* cell:21 */
+		"\xe2\x91\xb9",	/* cell:22 */
+		"\xe2\x91\xba",	/* cell:23 */
+		"\xe2\x91\xbb",	/* cell:24 */
+		"\xe2\x91\xbc",	/* cell:25 */
+		"\xe2\x91\xbd",	/* cell:26 */
+		"\xe2\x91\xbe",	/* cell:27 */
+		"\xe2\x91\xbf",	/* cell:28 */
+		"\xe3\x89\x91",	/* cell:29 */
+		"\xe3\x89\x92",	/* cell:30 */
+		"\xe3\x89\x93",	/* cell:31 */
+		"\xe3\x89\x94",	/* cell:32 */
+#ifdef USE_UNICODE_SQUAREDCJK
+		"\xf0\x9f\x84\x90",	/* cell:33 */
+		"\xf0\x9f\x84\x91",	/* cell:34 */
+		"\xf0\x9f\x84\x92",	/* cell:35 */
+		"\xf0\x9f\x84\x93",	/* cell:36 */
+		"\xf0\x9f\x84\x94",	/* cell:37 */
+		"\xf0\x9f\x84\x95",	/* cell:38 */
+		"\xf0\x9f\x84\x96",	/* cell:39 */
+		"\xf0\x9f\x84\x97",	/* cell:40 */
+		"\xf0\x9f\x84\x98",	/* cell:41 */
+		"\xf0\x9f\x84\x99",	/* cell:42 */
+		"\xf0\x9f\x84\x9a",	/* cell:43 */
+		"\xf0\x9f\x84\x9b",	/* cell:44 */
+		"\xf0\x9f\x84\x9c",	/* cell:45 */
+		"\xf0\x9f\x84\x9d",	/* cell:46 */
+		"\xf0\x9f\x84\x9e",	/* cell:47 */
+		"\xf0\x9f\x84\x9f",	/* cell:48 */
+		"\xf0\x9f\x84\xa0",	/* cell:49 */
+		"\xf0\x9f\x84\xa1",	/* cell:50 */
+		"\xf0\x9f\x84\xa2",	/* cell:51 */
+		"\xf0\x9f\x84\xa3",	/* cell:52 */
+		"\xf0\x9f\x84\xa4",	/* cell:53 */
+		"\xf0\x9f\x84\xa5",	/* cell:54 */
+		"\xf0\x9f\x84\xa6",	/* cell:55 */
+		"\xf0\x9f\x84\xa7",	/* cell:56 */
+		"\xf0\x9f\x84\xa8",	/* cell:57 */
+		"\xf0\x9f\x84\xa9",	/* cell:58 */
+#else
+		"(A)",	/* cell:33 */
+		"(B)",	/* cell:34 */
+		"(C)",	/* cell:35 */
+		"(D)",	/* cell:36 */
+		"(E)",	/* cell:37 */
+		"(F)",	/* cell:38 */
+		"(G)",	/* cell:39 */
+		"(H)",	/* cell:40 */
+		"(I)",	/* cell:41 */
+		"(J)",	/* cell:42 */
+		"(K)",	/* cell:43 */
+		"(L)",	/* cell:44 */
+		"(M)",	/* cell:45 */
+		"(N)",	/* cell:46 */
+		"(O)",	/* cell:47 */
+		"(P)",	/* cell:48 */
+		"(Q)",	/* cell:49 */
+		"(R)",	/* cell:50 */
+		"(S)",	/* cell:51 */
+		"(T)",	/* cell:52 */
+		"(U)",	/* cell:53 */
+		"(V)",	/* cell:54 */
+		"(W)",	/* cell:55 */
+		"(X)",	/* cell:56 */
+		"(Y)",	/* cell:57 */
+		"(Z)",	/* cell:58 */
+#endif
+		"\xe3\x89\x95",	/* cell:59 */
+		"\xe3\x89\x96",	/* cell:60 */
+		"\xe3\x89\x97",	/* cell:61 */
+		"\xe3\x89\x98",	/* cell:62 */
+		"\xe3\x89\x99",	/* cell:63 */
+		"\xe3\x89\x9a",	/* cell:64 */
+		"\xe2\x91\xa0",	/* cell:65 */
+		"\xe2\x91\xa1",	/* cell:66 */
+		"\xe2\x91\xa2",	/* cell:67 */
+		"\xe2\x91\xa3",	/* cell:68 */
+		"\xe2\x91\xa4",	/* cell:69 */
+		"\xe2\x91\xa5",	/* cell:70 */
+		"\xe2\x91\xa6",	/* cell:71 */
+		"\xe2\x91\xa7",	/* cell:72 */
+		"\xe2\x91\xa8",	/* cell:73 */
+		"\xe2\x91\xa9",	/* cell:74 */
+		"\xe2\x91\xaa",	/* cell:75 */
+		"\xe2\x91\xab",	/* cell:76 */
+		"\xe2\x91\xac",	/* cell:77 */
+		"\xe2\x91\xad",	/* cell:78 */
+		"\xe2\x91\xae",	/* cell:79 */
+		"\xe2\x91\xaf",	/* cell:80 */
+		"\xe2\x9d\xb6",	/* cell:81 */
+		"\xe2\x9d\xb7",	/* cell:82 */
+		"\xe2\x9d\xb8",	/* cell:83 */
+		"\xe2\x9d\xb9",	/* cell:84 */
+		"\xe2\x9d\xba",	/* cell:85 */
+		"\xe2\x9d\xbb",	/* cell:86 */
+		"\xe2\x9d\xbc",	/* cell:87 */
+		"\xe2\x9d\xbd",	/* cell:88 */
+		"\xe2\x9d\xbe",	/* cell:89 */
+		"\xe2\x9d\xbf",	/* cell:90 */
+		"\xe2\x93\xab",	/* cell:91 */
+		"\xe2\x93\xac",	/* cell:92 */
+		"\xe3\x89\x9b",	/* cell:93 */
+		REPLACEMENT_CHARACTER,	/* cell:94 */
+	}
+};
+
+/* Additional kanji */
+static const char * const codeset_Additional_symbols85[2][94] = {
+	{
+		/* row:85 */
+		"\xe3\x90\x82",	/* cell:1 */
+		"\xf0\xa0\x85\x98",	/* cell:2 */
+		"\xe4\xbb\xbd",	/* cell:3 */
+		"\xe4\xbb\xbf",	/* cell:4 */
+		"\xe4\xbe\x9a",	/* cell:5 */
+		"\xe4\xbf\x89",	/* cell:6 */
+		"\xe5\x82\x9c",	/* cell:7 */
+		"\xe5\x84\x9e",	/* cell:8 */
+		"\xe5\x86\xbc",	/* cell:9 */
+		"\xe3\x94\x9f",	/* cell:10 */
+		"\xe5\x8c\x87",	/* cell:11 */
+		"\xe5\x8d\xa1",	/* cell:12 */
+		"\xe5\x8d\xac",	/* cell:13 */
+		"\xe8\xa9\xb9",	/* cell:14 */
+		"\xf0\xa0\xae\xb7",	/* cell:15 */
+		"\xe5\x91\x8d",	/* cell:16 */
+		"\xe5\x92\x96",	/* cell:17 */
+		"\xe5\x92\x9c",	/* cell:18 */
+		"\xe5\x92\xa9",	/* cell:19 */
+		"\xe5\x94\x8e",	/* cell:20 */
+		"\xe5\x95\x8a",	/* cell:21 */
+		"\xe5\x99\xb2",	/* cell:22 */
+		"\xe5\x9b\xa4",	/* cell:23 */
+		"\xe5\x9c\xb3",	/* cell:24 */
+		"\xe5\x9c\xb4",	/* cell:25 */
+		"\xef\xa8\x90",	/* cell:26 */
+		"\xe5\xa2\x80",	/* cell:27 */
+		"\xe5\xa7\xa4",	/* cell:28 */
+		"\xe5\xa8\xa3",	/* cell:29 */
+		"\xe5\xa9\x95",	/* cell:30 */
+		"\xe5\xaf\xac",	/* cell:31 */
+		"\xef\xa8\x91",	/* cell:32 */
+		"\xe3\x9f\xa2",	/* cell:33 */
+		"\xe5\xba\xac",	/* cell:34 */
+		"\xe5\xbc\xb4",	/* cell:35 */
+		"\xe5\xbd\x85",	/* cell:36 */
+		"\xe5\xbe\xb7",	/* cell:37 */
+		"\xe6\x80\x97",	/* cell:38 */
+		"\xef\xa9\xab",	/* cell:39 */
+		"\xe6\x84\xb0",	/* cell:40 */
+		"\xe6\x98\xa4",	/* cell:41 */
+		"\xe6\x9b\x88",	/* cell:42 */
+		"\xe6\x9b\x99",	/* cell:43 */
+		"\xe6\x9b\xba",	/* cell:44 */
+		"\xe6\x9b\xbb",	/* cell:45 */
+		"\xe6\xa1\x92",	/* cell:46 */
+		"\xe9\xbf\x84",	/* cell:47 */
+		"\xe6\xa4\x91",	/* cell:48 */
+		"\xe6\xa4\xbb",	/* cell:49 */
+		"\xe6\xa9\x85",	/* cell:50 */
+		"\xe6\xaa\x91",	/* cell:51 */
+		"\xe6\xab\x9b",	/* cell:52 */
+		"\xf0\xa3\x8f\x8c",	/* cell:53 */
+		"\xf0\xa3\x8f\xbe",	/* cell:54 */
+		"\xf0\xa3\x97\x84",	/* cell:55 */
+		"\xe6\xaf\xb1",	/* cell:56 */
+		"\xe6\xb3\xa0",	/* cell:57 */
+		"\xe6\xb4\xae",	/* cell:58 */
+		"\xef\xa9\x85",	/* cell:59 */
+		"\xe6\xb6\xbf",	/* cell:60 */
+		"\xe6\xb7\x8a",	/* cell:61 */
+		"\xe6\xb7\xb8",	/* cell:62 */
+		"\xef\xa9\x86",	/* cell:63 */
+		"\xe6\xbd\x9e",	/* cell:64 */
+		"\xe6\xbf\xb9",	/* cell:65 */
+		"\xe7\x81\xa4",	/* cell:66 */
+		"\xef\xa9\xac",	/* cell:67 */
+		"\xf0\xa4\x8b\xae",	/* cell:68 */
+		"\xe7\x85\x87",	/* cell:69 */
+		"\xe7\x87\x81",	/* cell:70 */
+		"\xe7\x88\x80",	/* cell:71 */
+		"\xe7\x8e\x9f",	/* cell:72 */
+		"\xe7\x8e\xa8",	/* cell:73 */
+		"\xe7\x8f\x89",	/* cell:74 */
+		"\xe7\x8f\x96",	/* cell:75 */
+		"\xe7\x90\x9b",	/* cell:76 */
+		"\xe7\x90\xa1",	/* cell:77 */
+		"\xef\xa9\x8a",	/* cell:78 */
+		"\xe7\x90\xa6",	/* cell:79 */
+		"\xe7\x90\xaa",	/* cell:80 */
+		"\xe7\x90\xac",	/* cell:81 */
+		"\xe7\x90\xb9",	/* cell:82 */
+		"\xe7\x91\x8b",	/* cell:83 */
+		"\xe3\xbb\x9a",	/* cell:84 */
+		"\xe7\x95\xb5",	/* cell:85 */
+		"\xe7\x96\x81",	/* cell:86 */
+		"\xe7\x9d\xb2",	/* cell:87 */
+		"\xe4\x82\x93",	/* cell:88 */
+		"\xe7\xa3\x88",	/* cell:89 */
+		"\xe7\xa3\xa0",	/* cell:90 */
+		"\xe7\xa5\x87",	/* cell:91 */
+		"\xe7\xa6\xae",	/* cell:92 */
+		"\xe9\xbf\x86",	/* cell:93 */
+		"\xe4\x84\x83",	/* cell:94 */
+	}, {
+		/* row:86 */
+		"\xe9\xbf\x85",	/* cell:1 */
+		"\xe7\xa7\x9a",	/* cell:2 */
+		"\xe7\xa8\x9e",	/* cell:3 */
+		"\xe7\xad\xbf",	/* cell:4 */
+		"\xe7\xb0\xb1",	/* cell:5 */
+		"\xe4\x89\xa4",	/* cell:6 */
+		"\xe7\xb6\x8b",	/* cell:7 */
+		"\xe7\xbe\xa1",	/* cell:8 */
+		"\xe8\x84\x98",	/* cell:9 */
+		"\xe8\x84\xba",	/* cell:10 */
+		"\xef\xa9\xad",	/* cell:11 */
+		"\xe8\x8a\xae",	/* cell:12 */
+		"\xe8\x91\x9b",	/* cell:13 */
+		"\xe8\x93\x9c",	/* cell:14 */
+		"\xe8\x93\xac",	/* cell:15 */
+		"\xe8\x95\x99",	/* cell:16 */
+		"\xe8\x97\x8e",	/* cell:17 */
+		"\xe8\x9d\x95",	/* cell:18 */
+		"\xe8\x9f\xac",	/* cell:19 */
+		"\xe8\xa0\x8b",	/* cell:20 */
+		"\xe8\xa3\xb5",	/* cell:21 */
+		"\xe8\xa7\x92",	/* cell:22 */
+		"\xe8\xab\xb6",	/* cell:23 */
+		"\xe8\xb7\x8e",	/* cell:24 */
+		"\xe8\xbe\xbb",	/* cell:25 */
+		"\xe8\xbf\xb6",	/* cell:26 */
+		"\xe9\x83\x9d",	/* cell:27 */
+		"\xe9\x84\xa7",	/* cell:28 */
+		"\xe9\x84\xad",	/* cell:29 */
+		"\xe9\x86\xb2",	/* cell:30 */
+		"\xe9\x88\xb3",	/* cell:31 */
+		"\xe9\x8a\x88",	/* cell:32 */
+		"\xe9\x8c\xa1",	/* cell:33 */
+		"\xe9\x8d\x88",	/* cell:34 */
+		"\xe9\x96\x92",	/* cell:35 */
+		"\xe9\x9b\x9e",	/* cell:36 */
+		"\xe9\xa4\x83",	/* cell:37 */
+		"\xe9\xa5\x80",	/* cell:38 */
+		"\xe9\xab\x99",	/* cell:39 */
+		"\xe9\xaf\x96",	/* cell:40 */
+		"\xe9\xb7\x97",	/* cell:41 */
+		"\xe9\xba\xb4",	/* cell:42 */
+		"\xe9\xba\xb5",	/* cell:43 */
+		REPLACEMENT_CHARACTER,	/* cell:44 */
+		REPLACEMENT_CHARACTER,	/* cell:45 */
+		REPLACEMENT_CHARACTER,	/* cell:46 */
+		REPLACEMENT_CHARACTER,	/* cell:47 */
+		REPLACEMENT_CHARACTER,	/* cell:48 */
+		REPLACEMENT_CHARACTER,	/* cell:49 */
+		REPLACEMENT_CHARACTER,	/* cell:50 */
+		REPLACEMENT_CHARACTER,	/* cell:51 */
+		REPLACEMENT_CHARACTER,	/* cell:52 */
+		REPLACEMENT_CHARACTER,	/* cell:53 */
+		REPLACEMENT_CHARACTER,	/* cell:54 */
+		REPLACEMENT_CHARACTER,	/* cell:55 */
+		REPLACEMENT_CHARACTER,	/* cell:56 */
+		REPLACEMENT_CHARACTER,	/* cell:57 */
+		REPLACEMENT_CHARACTER,	/* cell:58 */
+		REPLACEMENT_CHARACTER,	/* cell:59 */
+		REPLACEMENT_CHARACTER,	/* cell:60 */
+		REPLACEMENT_CHARACTER,	/* cell:61 */
+		REPLACEMENT_CHARACTER,	/* cell:62 */
+		REPLACEMENT_CHARACTER,	/* cell:63 */
+		REPLACEMENT_CHARACTER,	/* cell:64 */
+		REPLACEMENT_CHARACTER,	/* cell:65 */
+		REPLACEMENT_CHARACTER,	/* cell:66 */
+		REPLACEMENT_CHARACTER,	/* cell:67 */
+		REPLACEMENT_CHARACTER,	/* cell:68 */
+		REPLACEMENT_CHARACTER,	/* cell:69 */
+		REPLACEMENT_CHARACTER,	/* cell:70 */
+		REPLACEMENT_CHARACTER,	/* cell:71 */
+		REPLACEMENT_CHARACTER,	/* cell:72 */
+		REPLACEMENT_CHARACTER,	/* cell:73 */
+		REPLACEMENT_CHARACTER,	/* cell:74 */
+		REPLACEMENT_CHARACTER,	/* cell:75 */
+		REPLACEMENT_CHARACTER,	/* cell:76 */
+		REPLACEMENT_CHARACTER,	/* cell:77 */
+		REPLACEMENT_CHARACTER,	/* cell:78 */
+		REPLACEMENT_CHARACTER,	/* cell:79 */
+		REPLACEMENT_CHARACTER,	/* cell:80 */
+		REPLACEMENT_CHARACTER,	/* cell:81 */
+		REPLACEMENT_CHARACTER,	/* cell:82 */
+		REPLACEMENT_CHARACTER,	/* cell:83 */
+		REPLACEMENT_CHARACTER,	/* cell:84 */
+		REPLACEMENT_CHARACTER,	/* cell:85 */
+		REPLACEMENT_CHARACTER,	/* cell:86 */
+		REPLACEMENT_CHARACTER,	/* cell:87 */
+		REPLACEMENT_CHARACTER,	/* cell:88 */
+		REPLACEMENT_CHARACTER,	/* cell:89 */
+		REPLACEMENT_CHARACTER,	/* cell:90 */
+		REPLACEMENT_CHARACTER,	/* cell:91 */
+		REPLACEMENT_CHARACTER,	/* cell:92 */
+		REPLACEMENT_CHARACTER,	/* cell:93 */
+		REPLACEMENT_CHARACTER,	/* cell:94 */
+	}
+};
+
+static const char * const codeset_Latin_extension[94] = {
+	"\xc2\xa1",	/* cell:1 */
+	"\xc2\xa2",	/* cell:2 */
+	"\xc2\xa3",	/* cell:3 */
+	"\xe2\x82\xac",	/* cell:4 */
+	"\xc2\xa5",	/* cell:5 */
+	"\xc5\xa0",	/* cell:6 */
+	"\xc2\xa7",	/* cell:7 */
+	"\xc5\xa1",	/* cell:8 */
+	"\xc2\xa9",	/* cell:9 */
+	"\xc2\xaa",	/* cell:10 */
+	"\xc2\xab",	/* cell:11 */
+	"\xc2\xac",	/* cell:12 */
+	"\xc2\xad",	/* cell:13 */
+	"\xc2\xae",	/* cell:14 */
+	"\xc2\xaf",	/* cell:15 */
+	"\xc2\xb0",	/* cell:16 */
+	"\xc2\xb1",	/* cell:17 */
+	"\xc2\xb2",	/* cell:18 */
+	"\xc2\xb3",	/* cell:19 */
+	"\xc5\xbd",	/* cell:20 */
+	"\xc2\xb5",	/* cell:21 */
+	"\xc2\xb6",	/* cell:22 */
+	"\xc2\xb7",	/* cell:23 */
+	"\xc5\xbe",	/* cell:24 */
+	"\xc2\xb9",	/* cell:25 */
+	"\xc2\xba",	/* cell:26 */
+	"\xc2\xbb",	/* cell:27 */
+	"\xc5\x92",	/* cell:28 */
+	"\xc5\x93",	/* cell:29 */
+	"\xc5\xb8",	/* cell:30 */
+	"\xc2\xbf",	/* cell:31 */
+	"\xc3\x80",	/* cell:32 */
+	"\xc3\x81",	/* cell:33 */
+	"\xc3\x82",	/* cell:34 */
+	"\xc3\x83",	/* cell:35 */
+	"\xc3\x84",	/* cell:36 */
+	"\xc3\x85",	/* cell:37 */
+	"\xc3\x86",	/* cell:38 */
+	"\xc3\x87",	/* cell:39 */
+	"\xc3\x88",	/* cell:40 */
+	"\xc3\x89",	/* cell:41 */
+	"\xc3\x8a",	/* cell:42 */
+	"\xc3\x8b",	/* cell:43 */
+	"\xc3\x8c",	/* cell:44 */
+	"\xc3\x8d",	/* cell:45 */
+	"\xc3\x8e",	/* cell:46 */
+	"\xc3\x8f",	/* cell:47 */
+	"\xc3\x90",	/* cell:48 */
+	"\xc3\x91",	/* cell:49 */
+	"\xc3\x92",	/* cell:50 */
+	"\xc3\x93",	/* cell:51 */
+	"\xc3\x94",	/* cell:52 */
+	"\xc3\x95",	/* cell:53 */
+	"\xc3\x96",	/* cell:54 */
+	"\xc3\x97",	/* cell:55 */
+	"\xc3\x98",	/* cell:56 */
+	"\xc3\x99",	/* cell:57 */
+	"\xc3\x9a",	/* cell:58 */
+	"\xc3\x9b",	/* cell:59 */
+	"\xc3\x9c",	/* cell:60 */
+	"\xc3\x9d",	/* cell:61 */
+	"\xc3\x9e",	/* cell:62 */
+	"\xc3\x9f",	/* cell:63 */
+	"\xc3\xa0",	/* cell:64 */
+	"\xc3\xa1",	/* cell:65 */
+	"\xc3\xa2",	/* cell:66 */
+	"\xc3\xa3",	/* cell:67 */
+	"\xc3\xa4",	/* cell:68 */
+	"\xc3\xa5",	/* cell:69 */
+	"\xc3\xa6",	/* cell:70 */
+	"\xc3\xa7",	/* cell:71 */
+	"\xc3\xa8",	/* cell:72 */
+	"\xc3\xa9",	/* cell:73 */
+	"\xc3\xaa",	/* cell:74 */
+	"\xc3\xab",	/* cell:75 */
+	"\xc3\xac",	/* cell:76 */
+	"\xc3\xad",	/* cell:77 */
+	"\xc3\xae",	/* cell:78 */
+	"\xc3\xaf",	/* cell:79 */
+	"\xc3\xb0",	/* cell:80 */
+	"\xc3\xb1",	/* cell:81 */
+	"\xc3\xb2",	/* cell:82 */
+	"\xc3\xb3",	/* cell:83 */
+	"\xc3\xb4",	/* cell:84 */
+	"\xc3\xb5",	/* cell:85 */
+	"\xc3\xb6",	/* cell:86 */
+	"\xc3\xb7",	/* cell:87 */
+	"\xc3\xb8",	/* cell:88 */
+	"\xc3\xb9",	/* cell:89 */
+	"\xc3\xba",	/* cell:90 */
+	"\xc3\xbb",	/* cell:91 */
+	"\xc3\xbc",	/* cell:92 */
+	"\xc3\xbd",	/* cell:93 */
+	"\xc3\xbe",	/* cell:94 */
+};
+
+static const char * const codeset_Special_character1[1] = {
+	"\xe2\x99\xaa",
+};
+
+static const char * const codeset_Special_character2[8] = {
+	"\xc2\xa4",
+	"\xc2\xa6",
+	"\xc2\xa8",
+	"\xc2\xb4",
+	"\xc2\xb8",
+	"\xc2\xbc",
+	"\xc2\xbd",
+	"\xc2\xbe",
+};
+
+static const char * const codeset_Special_character3[12] = {
+	"\xe2\x80\xa6",
+	"\xe2\x96\xae",
+	"\xe2\x80\x98",
+	"\xe2\x80\x99",
+	"\xe2\x80\x9c",
+	"\xe2\x80\x9d",
+	"\xe2\x80\xa2",
+	"\xe2\x84\xa2",
+	"\xe2\x85\x9b",
+	"\xe2\x85\x9c",
+	"\xe2\x85\x9d",
+	"\xe2\x85\x9e",
+};
+
+IsdbDecode isdb_decode_open(ISDBTYPE isdb)
+{
+	_IsdbDecode *_handle;
+
+	_handle = malloc(sizeof(*_handle));
+	assert(NULL != _handle);
+
+	_handle->isdb = isdb;
+
+	_handle->cd = iconv_open("UTF-8", "ISO-2022-JP-3");
+	assert((iconv_t)0 <= _handle->cd);
+
+	return (IsdbDecode)_handle;
+}
+
+void isdb_decode_close(IsdbDecode handle)
+{
+	_IsdbDecode *_handle;
+
+	_handle = (_IsdbDecode *)handle;
+	assert(NULL != _handle);
+
+	iconv_close(_handle->cd);
+	free(_handle);
+}
+
+static CODESET convert_codeset1(unsigned char code)
+{
+	switch (code) {
+	case CODESET_ALPHANUMERIC:	return Calpha;
+	case CODESET_HIRAGANA:	return Chiragana;
+	case CODESET_KATAKANA:	return Ckatakana;
+	case CODESET_P_ALPHANUMERIC:	return CPalpha;
+	case CODESET_P_HIRAGANA:	return CPhiragana;
+	case CODESET_P_KATAKANA:	return CPkatakana;
+	case CODESET_JISX0201KATAKANA:	return CJkatakana;
+	}
+
+	return Cnull;
+}
+
+static CODESET convert_codeset2(unsigned char code)
+{
+	switch (code) {
+	case CODESET_KANJI:	return Ckanji;
+	case CODESET_JIS_KANJI1:	return CJkanji1;
+	case CODESET_JIS_KANJI2:	return CJkanji2;
+	case CODESET_ADDITIONAL_SYMBOLS:	return Cadd;
+	}
+
+	return Cnull;
+}
+
+static void update_selectinfo_drcs2_5(SELECTINFO *si, IBUF *ibuf)
+{
+	unsigned char c;
+
+	if (!IBUF_isremain(ibuf))
+		return;
+	si = si;
+
+	c = IBUF_get(ibuf);
+}
+
+static void update_selectinfo_drcs1_4(SELECTINFO *si, IBUF *ibuf)
+{
+	unsigned char c;
+
+	if (!IBUF_isremain(ibuf))
+		return;
+	si = si;
+
+	c = IBUF_get(ibuf);
+}
+
+static void update_selectinfo_gset2_4(SELECTINFO *si, IBUF *ibuf)
+{
+	if (!IBUF_isremain(ibuf))
+		return;
+
+	switch (IBUF_get(ibuf)) {
+	case DRCS2BYTE_4:
+		update_selectinfo_drcs2_5(si, ibuf);
+		break;
+
+	default:
+		switch (IBUF_geti(ibuf, (-2))) {
+		case GSET2BYTE_3_G1:
+			si->g1 = convert_codeset2(IBUF_geti(ibuf, (-1)));
+			break;
+
+		case GSET2BYTE_3_G2:
+			si->g2 = convert_codeset2(IBUF_geti(ibuf, (-1)));
+			break;
+
+		case GSET2BYTE_3_G3:
+			si->g3 = convert_codeset2(IBUF_geti(ibuf, (-1)));
+			break;
+		}
+		break;
+	}
+}
+
+static void update_selectinfo_gset2_3(SELECTINFO *si, IBUF *ibuf)
+{
+	if (!IBUF_isremain(ibuf))
+		return;
+
+	switch (IBUF_get(ibuf)) {
+	case GSET2BYTE_3_G1:
+	case GSET2BYTE_3_G2:
+	case GSET2BYTE_3_G3:
+	case DRCS2BYTE_3_G0:
+		update_selectinfo_gset2_4(si, ibuf);
+		break;
+
+	default:
+		si->g0 = convert_codeset2(IBUF_geti(ibuf, (-1)));
+		break;
+	}
+}
+
+static void update_selectinfo_gset1_3(SELECTINFO *si, IBUF *ibuf)
+{
+	if (!IBUF_isremain(ibuf))
+		return;
+
+	switch (IBUF_get(ibuf)) {
+	case DRCS1BYTE_3:
+		update_selectinfo_drcs1_4(si, ibuf);
+		break;
+
+	default:
+		switch (IBUF_geti(ibuf, (-2))) {
+		case GSET1BYTE_2_G0:
+			si->g0 = convert_codeset1(IBUF_geti(ibuf, (-1)));
+			break;
+
+		case GSET1BYTE_2_G1:
+			si->g1 = convert_codeset1(IBUF_geti(ibuf, (-1)));
+			break;
+
+		case GSET1BYTE_2_G2:
+			si->g2 = convert_codeset1(IBUF_geti(ibuf, (-1)));
+			break;
+
+		case GSET1BYTE_2_G3:
+			si->g3 = convert_codeset1(IBUF_geti(ibuf, (-1)));
+			break;
+		}
+		break;
+	}
+}
+
+static void update_selectinfo_esc(SELECTINFO *si, IBUF *ibuf)
+{
+	if (!IBUF_isremain(ibuf))
+		return;
+
+	switch (IBUF_get(ibuf)) {
+	case LS2_2:
+		si->gl = G2;
+		break;
+
+	case LS3_2:
+		si->gl = G3;
+		break;
+
+	case LS1R_2:
+		si->gr = G1;
+		break;
+
+	case LS2R_2:
+		si->gr = G2;
+		break;
+
+	case LS3R_2:
+		si->gr = G3;
+		break;
+
+	case GSET1BYTE_2_G0:
+	case GSET1BYTE_2_G1:
+	case GSET1BYTE_2_G2:
+	case GSET1BYTE_2_G3:
+		update_selectinfo_gset1_3(si, ibuf);
+		break;
+
+	case GSET2BYTE_2:
+		update_selectinfo_gset2_3(si, ibuf);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static int update_selectinfo(SELECTINFO *si, IBUF *ibuf)
+{
+	unsigned char c;
+
+	switch (IBUF_geti(ibuf, 0)) {
+	case LS0:
+		c = IBUF_get(ibuf);
+		si->gl = G0;
+		break;
+
+	case LS1:
+		c = IBUF_get(ibuf);
+		si->gl = G1;
+		break;
+
+	case ESC:
+		c = IBUF_get(ibuf);
+		update_selectinfo_esc(si, ibuf);
+		break;
+
+	case SS2:
+		c = IBUF_get(ibuf);
+		si->ss = G2;
+		break;
+
+	case SS3:
+		c = IBUF_get(ibuf);
+		si->ss = G3;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void getcodeset(GLR glr, SELECTINFO *si, CODESET *cs, GSET *ss)
+{
+	GSET gs;
+
+	*ss = si->ss;
+	if (GL == glr) {
+		if (G2 == si->ss) {
+			gs = si->ss;
+			si->ss = Gnull;
+		}
+		else if (G3 == si->ss) {
+			gs = si->ss;
+			si->ss = Gnull;
+		}
+		else {
+			gs = si->gl;
+		}
+	}
+	else {
+		gs = si->gr;
+	}
+
+	*cs = Cnull;
+	switch (gs) {
+	case Gnull:
+		break;
+
+	case G0:
+		*cs = si->g0;
+		break;
+
+	case G1:
+		*cs = si->g1;
+		break;
+
+	case G2:
+		*cs = si->g2;
+		break;
+
+	case G3:
+		*cs = si->g3;
+		break;
+	}
+}
+
+static void convert_str_replacement_character(OBUF *obuf)
+{
+	const unsigned char *code;
+
+	code = (const unsigned char *)REPLACEMENT_CHARACTER;
+	while (*code) {
+		assert(OBUF_isremain(obuf));
+		OBUF_put(obuf, *code++);
+	}
+}
+
+static void convert_str_kanji(iconv_t cd, GLR glr, CODESET cs,
+							  GSET ss, unsigned char c,
+							  IBUF *ibuf, OBUF *obuf)
+{
+	int row, cell;
+	const unsigned char *code;
+	unsigned char c1;
+	char buf[3 + 1024 * 2], *p;
+	size_t size, left, rslt;
+
+	if (!IBUF_isremain(ibuf))
+		return;
+
+	p = buf;
+	switch (cs) {
+	case Ckanji:
+		row = c - 0x20;
+		if (ISADDITIONAL_SYMBOLS(row)) {
+			/* Additional symbols */
+			cell = (IBUF_get(ibuf) & 0x7f) - 0x20;
+			if (90 == row &&
+				((45 <= cell && cell <= 63) ||
+				 (66 <= cell && cell <= 84))) {
+				/* ARIB STD-B3 */
+				convert_str_replacement_character(obuf);
+			}
+
+			code = (const unsigned char *)codeset_Additional_symbols90[row - 90][cell - 1];
+			while (*code) {
+				assert(OBUF_isremain(obuf));
+				OBUF_put(obuf, *code++);
+			}
+			return;
+		}
+		*p++ = ESC;
+		*p++ = '$';
+		*p++ = 'B';
+		break;
+
+	case CJkanji1:
+		*p++ = ESC;
+		*p++ = '$';
+		*p++ = '(';
+		*p++ = 'Q';
+		break;
+
+	case CJkanji2:
+		*p++ = ESC;
+		*p++ = '$';
+		*p++ = '(';
+		*p++ = 'P';
+		break;
+
+	default:
+		return;
+	}
+
+	*p++ = (char)c;
+	*p++ = (char)(IBUF_get(ibuf) & 0x7f);
+	if (Gnull == ss) {
+		/* Locking shift */
+		while (IBUF_isremainn(ibuf, 1) &&
+			   p < buf + sizeof(buf)) {
+			c1 = IBUF_geti(ibuf, 0);
+			if (GL == glr && !ISGL(c1))
+				break;
+			if (GR == glr && !ISGR(c1))
+				break;
+			if (Ckanji == cs) {
+				c1 &= 0x7f;
+				row = c1 - 0x20;
+				if (ISADDITIONAL_SYMBOLS(row)) {
+					/* Additional symbols */
+					break;
+				}
+			}
+
+			*p++ = (char)(IBUF_get(ibuf) & 0x7f);
+			*p++ = (char)(IBUF_get(ibuf) & 0x7f);
+		}
+
+	}
+	else {
+		/* Single shift */
+	}
+	size = p - buf;
+	p = &buf[0];
+	left = (size_t)OBUF_putleft(obuf);
+	rslt = iconv(cd, &p, &size,
+				 (char **)OBUF_putp(obuf), &left);
+	assert(!((size_t)(-1) == rslt && E2BIG == errno));
+}
+
+static void convert_str_alpha(unsigned char c1, OBUF *obuf)
+{
+	if (c1 == 0x7e) {
+		/* over line */
+		assert(OBUF_isremainn(obuf, 3));
+		OBUF_put(obuf, (unsigned char)0xe2);
+		OBUF_put(obuf, (unsigned char)0x80);
+		OBUF_put(obuf, (unsigned char)0xbe);
+		return;
+	}
+
+	assert(OBUF_isremain(obuf));
+	OBUF_put(obuf, (unsigned char)codeset_Alphanumeric[c1 - 0x21]);
+}
+
+static void convert_str_hiragana(const char codeset[], int size,
+								 unsigned char c1, OBUF *obuf)
+{
+	int ind;
+
+	if (c1 - 0x21 >= size) {
+		convert_str_replacement_character(obuf);
+		return;
+	}
+	ind = ((int)c1 - 0x21) * 3;
+	assert(OBUF_isremainn(obuf, 3));
+	OBUF_put(obuf, (unsigned char)codeset[ind++]);
+	OBUF_put(obuf, (unsigned char)codeset[ind++]);
+	OBUF_put(obuf, (unsigned char)codeset[ind++]);
+}
+
+static void convert_str_add(unsigned char c1, unsigned char c2, OBUF *obuf)
+{
+	int row, cell;
+	const unsigned char *code;
+
+	row = c1 - 0x20;
+	cell = c2 - 0x20;
+	if (ISADDITIONAL_SYMBOLS(row)) {
+		/* Additional symbols */
+		code = (const unsigned char *)codeset_Additional_symbols90[row - 90][cell - 1];
+	}
+	else if (ISADDITIONAL_KANJI(row)) {
+		/* Additional kanji */
+		code = (const unsigned char *)codeset_Additional_symbols85[row - 85][cell - 1];
+	}
+	else {
+		convert_str_replacement_character(obuf);
+		return;
+	}
+	while (*code) {
+		assert(OBUF_isremain(obuf));
+		OBUF_put(obuf, *code++);
+	}
+}
+
+static void convert_str_extension(unsigned char c1, OBUF *obuf)
+{
+	const unsigned char *code;
+
+	code = (const unsigned char *)codeset_Latin_extension[c1 - 0x21];
+	while (*code) {
+		assert(OBUF_isremain(obuf));
+		OBUF_put(obuf, *code++);
+	}
+}
+
+static void convert_str_special(unsigned char c1, OBUF *obuf)
+{
+	const unsigned char *code;
+
+	if (0x21 <= c1 && c1 <= 0x21)
+		code = (const unsigned char *)codeset_Special_character1[c1 - 0x21];
+	else if (0x30 <= c1 && c1 <= 0x37)
+		code = (const unsigned char *)codeset_Special_character2[c1 - 0x30];
+	else if (0x40 <= c1 && c1 <= 0x4b)
+		code = (const unsigned char *)codeset_Special_character2[c1 - 0x40];
+	else {
+		convert_str_replacement_character(obuf);
+		return;
+	}
+	while (*code) {
+		assert(OBUF_isremain(obuf));
+		OBUF_put(obuf, *code++);
+	}
+}
+
+static void convert_str_codeset(iconv_t cd, GLR glr, CODESET cs,
+								GSET ss, unsigned char c,
+								IBUF *ibuf, OBUF *obuf)
+{
+	unsigned char c2;
+
+	switch (cs) {
+	case Ckanji:
+	case CJkanji1:
+	case CJkanji2:
+		convert_str_kanji(cd, glr, cs, ss, c, ibuf, obuf);
+		break;
+
+	case Calpha:
+	case CPalpha:
+		convert_str_alpha(c, obuf);
+		break;
+
+	case Chiragana:
+	case CPhiragana:
+		convert_str_hiragana(codeset_Hiragana, 94, c, obuf);
+		break;
+
+	case Ckatakana:
+	case CPkatakana:
+		convert_str_hiragana(codeset_Katakana, 94, c, obuf);
+		break;
+
+	case CJkatakana:
+		convert_str_hiragana(codeset_JISX0201katakana, 63, c, obuf);
+		break;
+
+	case Cadd:
+		if (!IBUF_isremain(ibuf))
+			break;
+		c2 = IBUF_get(ibuf);
+		convert_str_add(c, (c2 & 0x7f), obuf);
+		break;
+
+	case Cextension:
+		convert_str_extension(c, obuf);
+		break;
+
+	case Cspecial:
+		convert_str_special(c, obuf);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void skip_cs0(unsigned char c, IBUF *ibuf)
+{
+	switch (c) {
+	case PAPF:
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		break;
+
+	case APS:
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		break;
+
+	default:
+		break;
+	}
+}
+
+static void skip_cs1(unsigned char c, IBUF *ibuf)
+{
+	switch (c) {
+	case POL:
+	case SZX:
+	case FLC:
+	case WMM:
+	case RPC:
+	case HLC:
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		break;
+
+	case COL:
+	case CDC:
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		if (c == 0x20) {
+			if (!IBUF_isremain(ibuf)) break;
+			c = IBUF_get(ibuf);
+		}
+		break;
+
+	case TIME:
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		if (c == 0x20) {
+			if (!IBUF_isremain(ibuf)) break;
+			c = IBUF_get(ibuf);
+		}
+		else if (c == 0x28) {
+			if (!IBUF_isremain(ibuf)) break;
+			c = IBUF_get(ibuf);
+		}
+		else if (c == 0x29) {
+			while (IBUF_isremain(ibuf)) {
+				c = IBUF_get(ibuf);
+				if (0x40 <= c && c <= 0x42)
+					break;
+			}
+		}
+		break;
+
+	case MACRO:
+		while (IBUF_isremain(ibuf)) {
+			c = IBUF_get(ibuf);
+			if (c == MACRO)
+				break;
+		}
+		if (!IBUF_isremain(ibuf)) break;
+		c = IBUF_get(ibuf);
+		break;
+
+	case CSI:
+		while (IBUF_isremain(ibuf)) {
+			c = IBUF_get(ibuf);
+			if (0x40 <= c && c <= 0x6f)
+				break;
+		}
+		break;
+
+	default:
+		break;
+	}
+}
+
+unsigned int isdb_decode_text(IsdbDecode handle,
+			  const unsigned char *src, unsigned int src_len,
+			  unsigned char *dst, unsigned int dst_len)
+{
+	_IsdbDecode *_handle;
+	unsigned int rslt;
+	SELECTINFO si;
+	CODESET cs;
+	GSET ss;
+	IBUF ibuf;
+	OBUF obuf;
+	unsigned char c;
+
+	_handle = (_IsdbDecode *)handle;
+	assert(NULL != _handle);
+
+	rslt = 0;
+	switch (_handle->isdb) {
+	case ISDB_ARIB:
+		si.gl = G0;
+		si.gr = G2;
+		si.ss = Gnull;
+		si.g0 = Ckanji;
+		si.g1 = Calpha;
+		si.g2 = Chiragana;
+		si.g3 = Ckatakana;	/* macro??? */
+		break;
+
+	case ISDB_ABNT:
+		si.gl = G0;
+		si.gr = G1;
+		si.g0 = Calpha;
+		si.g1 = Cextension;
+		break;
+	}
+
+	IBUF_init(&ibuf, src, src_len);
+	OBUF_init(&obuf, dst, dst_len);
+	while (IBUF_isremain(&ibuf)) {
+		while (update_selectinfo(&si, &ibuf) &&
+			   IBUF_isremain(&ibuf))
+			;
+		if (!IBUF_isremain(&ibuf))
+			break;
+
+		c = IBUF_get(&ibuf);
+		if (c < 0x80) {
+			if (ISGL(c)) {
+				getcodeset(GL, &si, &cs, &ss);
+				convert_str_codeset(_handle->cd, GL, cs, ss, c, &ibuf, &obuf);
+			}
+			else if (c == SP ||
+					 c == APD) {
+				assert(OBUF_isremain(&obuf));
+				OBUF_put(&obuf, c);
+			}
+			else {
+				skip_cs0(c, &ibuf);
+			}
+		}
+		else {
+			if (ISGR(c)) {
+				getcodeset(GR, &si, &cs, &ss);
+				convert_str_codeset(_handle->cd, GR, cs, ss, (c & 0x7f), &ibuf, &obuf);
+			}
+			else {
+				skip_cs1(c, &ibuf);
+			}
+		}
+	}
+	rslt = dst_len - (unsigned int)OBUF_putleft(&obuf);
+
+#ifdef DEBUG
+	{
+		struct timeval tv;
+		struct tm *tm;
+		FILE *fpsrc, *fpsrc2, *fpdst;
+		char mark[128];
+		unsigned int i;
+
+		gettimeofday(&tv, NULL);
+		tm = localtime(&tv.tv_sec);
+		sprintf(mark, "%02d:%02d:%02d.%06ld ",
+				tm->tm_hour, tm->tm_min, tm->tm_sec, (long int)tv.tv_usec);
+
+		pthread_mutex_lock(&mut);
+		fpsrc = fopen("/tmp/isdb_decode_src.txt", "a");
+		fpsrc2 = fopen("/tmp/isdb_decode_src2.txt", "a");
+		fpdst = fopen("/tmp/isdb_decode_dst.txt", "a");
+		assert(fpsrc && fpdst);
+
+		fputs(mark, fpsrc);
+		for (i = 0; i < src_len; i++) {
+			if (i % 20 == 0 && i > 0)
+				fputs("\n", fpsrc);
+			fprintf(fpsrc, "%02x ", src[i]);
+		}
+		fputs("\n", fpsrc);
+
+		fputs(mark, fpsrc2);
+		fwrite(src, (size_t)src_len, (size_t)1, fpsrc2);
+		fputs("\n", fpsrc2);
+
+		fputs(mark, fpdst);
+		fwrite(dst, (size_t)rslt, (size_t)1, fpdst);
+		fputs("\n", fpdst);
+
+		fclose(fpdst);
+		fclose(fpsrc2);
+		fclose(fpsrc);
+		pthread_mutex_unlock(&mut);
+	}
+#endif
+
+	return rslt;
+}
+
+/*
+ * Local Variables:
+ * c-basic-offset: 4
+ * indent-tabs-mode: t
+ * tab-width: 4
+ * End:
+ */
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/isdb_decode_text.h
===================================================================
--- /dev/null
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/isdb_decode_text.h
@@ -0,0 +1,29 @@
+#ifndef ISDB_DECODE_TEXT_H
+#define ISDB_DECODE_TEXT_H
+
+typedef enum { ISDB_ARIB, ISDB_ABNT } ISDBTYPE;
+typedef void *IsdbDecode;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+IsdbDecode isdb_decode_open(ISDBTYPE isdb);
+void isdb_decode_close(IsdbDecode handle);
+unsigned int isdb_decode_text(IsdbDecode handle,
+                                                         const unsigned char *src, unsigned int src_len,
+                                                         unsigned char *dst, unsigned int dst_len);
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ISDB_DECODE_TEXT_H */
+
+/*
+ * Local Variables:
+ * c-basic-offset: 4
+ * indent-tabs-mode: t
+ * tab-width: 4
+ * End:
+ */
+
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/mpegdescriptors.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/mpegdescriptors.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/mpegdescriptors.cpp
@@ -97,6 +97,7 @@ desc_list_t MPEGDescriptor::FindAll(cons
     return tmp;
 }
 
+/*
 static uint maxPriority(const QMap<uint,uint> &langPrefs)
 {
     uint max_pri = 0;
@@ -207,6 +208,7 @@ desc_list_t MPEGDescriptor::FindBestMatc
 
     return tmp;
 }
+*/
 
 #define EMPTY_STR_16 "","","","", "","","","", "","","","", "","","","",
 
@@ -387,6 +389,7 @@ QString MPEGDescriptor::DescriptorTagStr
     if (IsValid()) { DESC_NAME d(m_data, DescriptorLength()+2); \
     if (d.IsValid()) str = d.toString(); } } while (false)
 
+
 QString MPEGDescriptor::descrDump(const QString &name) const
 {
     QString str;
@@ -430,11 +433,12 @@ QString MPEGDescriptor::toStringPD(uint
     else if (DescriptorID::hevc_video == DescriptorTag())
     {
         SET_STRING(HEVCVideoDescriptor);
+	// ToDo: Check not comment out is right 20200324
     }
-    else if (DescriptorID::network_name == DescriptorTag())
-    {
-        SET_STRING(NetworkNameDescriptor);
-    }
+//    else if (DescriptorID::network_name == DescriptorTag())
+//  {
+//       SET_STRING(NetworkNameDescriptor);
+//  }
     else if (DescriptorID::service_list == DescriptorTag())
     {
         SET_STRING(ServiceListDescriptor);
@@ -446,15 +450,16 @@ QString MPEGDescriptor::toStringPD(uint
     else if (DescriptorID::cable_delivery_system == DescriptorTag())
     {
         SET_STRING(CableDeliverySystemDescriptor);
+	// ToDo: Check not comment out is right 20200324
     }
-    else if (DescriptorID::bouquet_name == DescriptorTag())
-    {
-        SET_STRING(BouquetNameDescriptor);
-    }
-    else if (DescriptorID::service == DescriptorTag())
-    {
-        SET_STRING(ServiceDescriptor);
-    }
+//    else if (DescriptorID::bouquet_name == DescriptorTag())
+//    {
+//        SET_STRING(BouquetNameDescriptor);
+//    }
+//    else if (DescriptorID::service == DescriptorTag())
+//    {
+//        SET_STRING(ServiceDescriptor);
+//    }
     else if (DescriptorID::country_availability == DescriptorTag())
     {
         SET_STRING(CountryAvailabilityDescriptor);
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/mpegdescriptors.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/mpegdescriptors.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/mpegdescriptors.h
@@ -266,6 +266,13 @@ class OriginalNetworkID
     };
 };
 
+typedef enum
+{
+    kKindUnknown = 0,
+    kKindDVB     = 1,
+    kKindISDB    = 2,
+} DVBKind;
+
 class MTV_PUBLIC MPEGDescriptor
 {
   public:
@@ -313,11 +320,6 @@ class MTV_PUBLIC MPEGDescriptor
     static const unsigned char *Find(const desc_list_t &parsed, uint desc_tag);
     static desc_list_t FindAll(const desc_list_t &parsed, uint desc_tag);
 
-    static const unsigned char *FindBestMatch(
-        const desc_list_t &parsed, uint desc_tag, QMap<uint,uint> &langPref);
-    static desc_list_t FindBestMatches(
-        const desc_list_t &parsed, uint desc_tag, QMap<uint,uint> &langPref);
-
   protected:
     const unsigned char *m_data;
 
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/scanstreamdata.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/scanstreamdata.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/scanstreamdata.cpp
@@ -4,10 +4,10 @@
 #include "atsctables.h"
 #include "dvbtables.h"
 
-ScanStreamData::ScanStreamData(bool no_default_pid) :
+ScanStreamData::ScanStreamData(bool no_default_pid, DVBKind dvbkind) :
     MPEGStreamData(-1, -1, true),
     ATSCStreamData(-1, -1, -1, true),
-    DVBStreamData(0, 0, -1, -1, true),
+    DVBStreamData(0, 0, -1, -1, true, dvbkind),
     m_noDefaultPid(no_default_pid)
 {
     if (m_noDefaultPid)
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/scanstreamdata.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/scanstreamdata.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/scanstreamdata.h
@@ -13,7 +13,7 @@ class MTV_PUBLIC ScanStreamData :
     public DVBStreamData
 {
   public:
-    explicit ScanStreamData(bool no_default_pid = false);
+    explicit ScanStreamData(bool no_default_pid = false, DVBKind dvbkind = kKindDVB);
     ~ScanStreamData() override;
 
     bool IsRedundant(uint pid, const PSIPTable &psip) const override; // ATSCStreamData
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/sctedescriptors.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/mpeg/sctedescriptors.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/mpeg/sctedescriptors.h
@@ -26,6 +26,7 @@
 #include <QString>
 
 // MythTV
+#include "dvbdescriptors.h"
 #include "mpegdescriptors.h"
 
 // SCTE 57 p 83
@@ -103,11 +104,11 @@ class ExtendedVideoDescriptor : public M
 };
 
 // SCTE 57 p 85
-class SCTEComponentNameDescriptor : public MPEGDescriptor
+class SCTEComponentNameDescriptor : public DVBDescriptor
 {
   public:
-    SCTEComponentNameDescriptor(const unsigned char *data, uint len) :
-        MPEGDescriptor(data, len, DescriptorID::scte_component_name)
+    SCTEComponentNameDescriptor(const unsigned char *data, DVBKind dvbkind, int len = 300) :
+        DVBDescriptor(data, dvbkind, len, DescriptorID::scte_component_name)
     {
         // TODO make sure descriptor is long enough.. set _data NULL otherwise
     }
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/recorders/dtvchannel.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/recorders/dtvchannel.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/recorders/dtvchannel.cpp
@@ -229,7 +229,7 @@ bool DTVChannel::SetChannelByString(cons
         frequency = (freqid.toULongLong() + finetune) * 1000;
         mplexid = 0;
     }
-    bool isFrequency = (frequency > 10000000);
+    bool isFrequency = (frequency > 1000000);
     bool hasTuneToChan =
         !m_tuneToChannel.isEmpty() && m_tuneToChannel != "Undefined";
 
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/recorders/dvbchannel.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/recorders/dvbchannel.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/recorders/dvbchannel.cpp
@@ -39,6 +39,7 @@
 #include <sys/select.h>
 #include <sys/time.h>
 #include <sys/types.h>
+#include <linux/version.h>
 
 // MythTV headers
 #include "mythconfig.h"
@@ -662,7 +663,7 @@ bool DVBChannel::Tune(const DTVMultiplex
     {
         LOG(VB_GENERAL, LOG_ERR, LOC +
             "DVB-S/S2 needs device tree for LNB handling");
-        return false;
+//        return false; // OK?
     }
 
     m_desiredTuning = tuning;
@@ -810,12 +811,52 @@ bool DVBChannel::Tune(const DTVMultiplex
             struct dvb_frontend_parameters params = dtvmultiplex_to_dvbparams(
                 m_tunerType, tuning, intermediate_freq, can_fec_auto);
 
-            if (ioctl(m_fdFrontend, FE_SET_FRONTEND, &params) < 0)
+//            if (ioctl(m_fdFrontend, FE_SET_FRONTEND, &params) < 0)
+            if (DTVTunerType::kTunerTypeDVBS1 == m_tunerType)
             {
-                LOG(VB_GENERAL, LOG_ERR, LOC +
-                    "Tune(): Setting Frontend tuning parameters failed." + ENO);
-                return false;
+                usleep(500 * 1000);
+
+                struct dtv_properties *cmds;
+
+                cmds = (struct dtv_properties*) calloc(1, sizeof(*cmds));
+                cmds->props = (struct dtv_property*) calloc(11, sizeof(*(cmds->props)));
+                cmds->props[0].cmd      = DTV_VOLTAGE;
+                cmds->props[0].u.data   = SEC_VOLTAGE_18;
+                cmds->props[1].cmd      = DTV_FREQUENCY;
+                cmds->props[1].u.data   = tuning.m_frequency;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,7,0)
+				cmds->props[2].cmd      = DTV_ISDBS_TS_ID;
+#else
+				cmds->props[2].cmd      = DTV_ISDBS_TS_ID_LEGACY;
+#endif
+                cmds->props[2].u.data   = tuning.m_transportid;
+                cmds->props[3].cmd      = DTV_TUNE;
+                cmds->props[3].u.data   = 1;
+                cmds->num = 4;
+
+                int res = ioctl(m_fdFrontend, FE_SET_PROPERTY, cmds);
+
+                free(cmds->props);
+                free(cmds);
+
+                if (res < 0)
+                {
+                    LOG(VB_GENERAL, LOG_ERR, LOC +
+                        "Tune(): Setting Frontend tuning parameters failed." + ENO);
+                    return false;
+                }
             }
+			else
+			{
+                struct dvb_frontend_parameters params = dtvmultiplex_to_dvbparams(
+                    m_tunerType, tuning, intermediate_freq, can_fec_auto);
+                if (ioctl(m_fdFrontend, FE_SET_FRONTEND, &params) < 0)
+                {
+                    LOG(VB_GENERAL, LOG_ERR, LOC +
+                        "Tune(): Setting Frontend tuning parameters failed." + ENO);
+                    return false;
+                }
+			}
         }
 
         // Extra delay to add for broken DVB drivers
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/recorders/dvbstreamhandler.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/recorders/dvbstreamhandler.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/recorders/dvbstreamhandler.cpp
@@ -142,15 +142,17 @@ void DVBStreamHandler::RunTS(void)
         if (dvr_fd >= 0)
             break;
 
+        int openerr = errno;
         LOG(VB_GENERAL, LOG_WARNING, LOC +
             QString("Opening DVR device %1 failed : %2")
-                .arg(m_dvrDevPath).arg(strerror(errno)));
+			.arg(m_dvrDevPath).arg(QString::fromLocal8Bit(strerror(errno))));
 
-        if (tries >= 20 || (errno != EBUSY && errno != EAGAIN))
+
+        if (tries >= 20 || (openerr != EBUSY && openerr != EAGAIN))
         {
             LOG(VB_GENERAL, LOG_ERR, LOC +
                 QString("Failed to open DVR device %1 : %2")
-                    .arg(m_dvrDevPath).arg(strerror(errno)));
+				.arg(m_dvrDevPath).arg(QString::fromLocal8Bit(strerror(errno))));
             m_bError = true;
             return;
         }
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/tv_rec.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/tv_rec.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/tv_rec.cpp
@@ -1919,7 +1919,18 @@ bool TVRec::SetupDTVSignalMonitor(bool E
         auto *dsd = dynamic_cast<DVBStreamData*>(sd);
         if (!dsd)
         {
-            sd = dsd = new DVBStreamData(netid, tsid, progNum, m_inputId);
+            DVBChannel *dvbchannel = dynamic_cast<DVBChannel*>(m_channel);
+            if (dvbchannel)
+            {
+                DVBKind dvbkind;
+                if (dvbchannel->GetFrontendName().indexOf("ISDB") >= 0)
+                    dvbkind = kKindISDB;
+                else
+                    dvbkind = kKindDVB;
+                sd = dsd = new DVBStreamData(netid, tsid, progNum, m_inputId, false, dvbkind);
+            }
+            else
+                sd = dsd = new DVBStreamData(netid, tsid, progNum, m_inputId);
             sd->SetCaching(true);
             if (GetDTVRecorder())
                 GetDTVRecorder()->SetStreamData(dsd);
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/tv_rec.h
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/libs/libmythtv/tv_rec.h
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/libs/libmythtv/tv_rec.h
@@ -30,6 +30,7 @@
 #include "videoouttypes.h"              // for PictureAttribute
 
 #include "mythconfig.h"
+#include "recorders/dvbchannel.h"
 
 // locking order
 // setChannelLock -> stateChangeLock -> triggerEventLoopLock
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/programs/mythutil/commandlineparser.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/programs/mythutil/commandlineparser.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/programs/mythutil/commandlineparser.cpp
@@ -3,6 +3,7 @@
 
 // local headers
 #include "commandlineparser.h"
+#include "mpegdescriptors.h"
 
 MythUtilCommandLineParser::MythUtilCommandLineParser() :
     MythCommandLineParser(MYTH_APPNAME_MYTHUTIL)
@@ -37,7 +38,7 @@ void MythUtilCommandLineParser::LoadArgu
                 ->SetGroup("MPEG-TS")
                 ->SetRequiredChild("infile")
                 ->SetChild("outfile")
-
+								
         // markuputils.cpp
         << add("--gencutlist", "gencutlist", false,
                 "Copy the commercial skip list to the cutlist.", "")
@@ -196,7 +197,13 @@ void MythUtilCommandLineParser::LoadArgu
         ->SetChildOf("pidprinter");
     add("--xml", "xml", false, "Enables XML output of PSIP", "")
         ->SetChildOf("pidprinter");
-
+	
+    add("--is_dvb", "is_dvb", false, "Select wheather stream is DVB.", "")
+        ->SetChildOf("pidprinter");
+	
+    add("--is_isdb", "is_isdb", true, "Select wheather stream is ISDB-T/S.", "")
+        ->SetChildOf("pidprinter");
+	
     // messageutils.cpp
     add("--message_text", "message_text", "message", "(optional) message to send", "")
         ->SetChildOf("message")
Index: mythtv-dmo-31.0+fixes20200926.git8ca7747648/programs/mythutil/mpegutils.cpp
===================================================================
--- mythtv-dmo-31.0+fixes20200926.git8ca7747648.orig/programs/mythutil/mpegutils.cpp
+++ mythtv-dmo-31.0+fixes20200926.git8ca7747648/programs/mythutil/mpegutils.cpp
@@ -746,7 +746,13 @@ static int pid_printer(const MythUtilCom
     bool autopts = !cmdline.toBool("noautopts");
     bool use_xml = cmdline.toBool("xml");
 
-    auto *sd = new ScanStreamData(true);
+	bool isISDB = cmdline.toBool("is_isdb");
+	bool isDVB = cmdline.toBool("is_dvb");
+	DVBKind dvbkind = kKindISDB;
+	if((isDVB) || !(isISDB)) {
+		dvbkind = kKindDVB;
+	}
+    auto *sd = new ScanStreamData(true, dvbkind);
     for (QHash<uint,bool>::iterator it = use_pid.begin();
          it != use_pid.end(); ++it)
     {
